# 7강\(by wiseCow\)

---

인터럽트 처리\(Interrupt Handling\)에 대한 내용을 다룰 것이다. 소프트웨어로서의 인터럽트를 설명하기 위해 자료 구조\(Data Structure\)와 함수\(Function\) 이 두가지로 설명으로 구성했다.

## 7.1 Data Structure for Interrupt Handling

---

6강에서 사용했던 용어들이 이번 7강에서도 그대로 사용된다. CPU에 인터럽트를 거는 것을 Interrupt ReQuest라고 다뤘다. 또한 컴퓨터에 여러 I/O Device가 있을 경우 각각을 IRQ line을 통해 관리한다고 했다. 아래 템플릿의 우측 네모박스를 살펴보면, 여러 Device들이 IRQ line에 달려 있다. 매 라인마다 디바이스들을 매단 형태로 되어 있다. 또한 각 디바이스들이 동시에 인터럽트를 요청하는 상황이 발생할 수 있기 때문에, 각 작업들의 교통 정리를 담당하는 PIC\(Programmable Interrupt Controller\)를 따로 두었다. Programmable 이란 표현이 쓰인 것은, 각각의 디바이스들이 file 형태로 시스템 내에 존재하고 각 디바이스를 0과 1의 형태로 제어할 수 있기 때문이다. PIC가 존재함으로써 아무리 많은 인터럽트가 들어와도 한 번에 하나씩 CPU에 전달될 수 있다.

![](/assets/Chapter 7_0.PNG)

지금부터는 위 템플릿과 함께 각 IRQ line을 자세히 살펴보도록 한다. 위 템플릿의 좌측의 노란 박스는 각 line이 가지고 있는 구조체다. 그리고 우측상단 박스에는 해당 구조체의 상태\(Status\)에 대해 서술되어 있다.

* IRQ\_DISABLED - 인터럽트 자체가 허용이 안된다. \(마스킹이 되있거나 그렇지 않거나.\) 라인 자체를 mask out 시켜놨다.
* IRQ\_WAITING - 인터럽트 자체는 허용이 되었지만, 아직 발생하지 않았다.
* IRQ\_PENDING - 인터럽트가 발생했데, 커널이 아직도 이 인터럽트를 서비스하지 못하고 있다.
* IRQ\_INPROGRESS - 커널이 해당 ISR\(Interrupt Service Routine\)를 실행하고 있다.

또한 각 IRQ line이 서비스 해줘야할 디바이스들이 여럿 존재하는데, 이 디바이스들의 각 처리는 action 필드에 저장되어 있는 주솟값을 따라가면 해당 디바이스들의 ISR이 연결 리스트 형태로 줄줄이 나오게 되어 있다. IRQ line이 여럿 존재하기 때문에 좌측 노란 구조체들은 배열로서 존재하고 있다. 아래 템플릿을 보면 알 수 있다.

![](/assets/Chapter 7_1.PNG)

위에서 언급했듯, action 필드를 따라가면 각 디바이스의 dev handler를 만날 수 있고, next필드를 따라 쭈욱 연결리스트로 구현된 디바이스들의 dev handler를 실행할 수 있다. line이 3개가 존재한다고 하면, 위 템플릿 처럼 3개의 struct 배열이 존재하게 되고, 이 배열의 이름을 여기선 irq\_desc\[ \]로 정의하고 있다; 보통 desc는 describe의 약어로 사용된다.

멀티 프로세서 \(CPU\) 시스템 내에서 PIC는 들어온 인터럽트들을 각 CPU에게 분배해준다. CPU가 인터럽트를 받아들일 때 제일 먼저 접근하는 자료구조는 irq\_desc 내의 Status가 되는데, 여러 CPU가 존재한다고 했으니 일단 irq desc 배열 자체는 Shared variable이다.

Mutual Exclusion 원칙이 적용되어야 하므로, irq desc에는 Lock이 존재하고 있다. 사용할 때 Lock을 걸어두고 사용이 끝나면 Lock을 해제하여 동일한 순간에 서로 다른 CPU가 접근하는 것을 막아준다. Handler 필드의 역할은 어느 PIC에서 왔는지를 알려주는 역할인데, 이 때의 PIC는 CPU와 PIC사이에 존재하는 로컬 PIC를 의미한다. 

