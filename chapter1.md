# 1강

#### 커널을 공부하는 마음가짐

**리눅스 커널\(Linux Kernel\)**을 한 사람이 전부 아는 것은 불가능하다. 커널 관련 두터운 원서를 75 ~ 80권 정도는 읽어야 "아, 한 번씩은 훑어봤다"라고 말할 수 있을 정도다. IBM과 같은 대형회사에서도 리눅스를 다루는 사람만 250명 정도가 있다고 한다. 250명의 사람이 방대한 커널에서 각자 분야를 맡아서 일을 처리한다.

따라서 **"모든 걸 다 알아야지!" **라는 마음가짐 보다는** "커널과 운영체제가 어떤 식으로 동작하는지 개략적으로 이해해보자"**라는 수준의 마음가짐을 가지는 것이 좋겠다.

### 운영체제란?

**운영체제\(Operating System\)**란 하드웨어 자원들\(cpu, memory, disk, tty\)을 **관리하고** 프로그램들을 **지원\(support\) 해주는 것**이다. \(우측에 있는 그림을 살펴보면, Operating System의 아래에 하드웨어들이 있고 그 위로는 프로그램들이 있다.\)

![](/assets/0.PNG)

다르게 표현해본다면, **하드웨어를 감추고 겉으로 다른 프로그램들을 지원해준다**고 생각할 수 있다. 하드웨어를 감춘다는 건, 프로그램을 사용하는 사람이 편하게 쓸 수 있게 각종 기반 작업을 지원한다는 것으로 이해할 수 있다.

Note: 일반적으로 우리는 파워포인트나 워드를 쓸 때 프로그램이 cpu와 memory와 어떻게 소통하는지 등에 대해서 따로 신경쓰지 않는다. 이는 다 운영체제 덕분이다.



#### 프로그램이란?

코딩을 해봤다면 main\( \)함수의 존재에 대해서 알 것이다. 프로그램이란 main\( \)함수를 포함하여 다른 다양한 기능들을 하는 함수들이 모인 존재라고 생각할 수 있다. 함수들이 적혀 있는 소스코드 파일을 컴파일 하면 프로그램이 된다는 것을 우리는 알고 있다.

\*.c 파일을 컴파일해서 a.out 혹은 \*.exe 등이 생성되고 우리는 이걸 프로그램이라 부른다.

여기서 한 가지 생각해볼 점이 있다. 왜 대부분의 프로그램은 분리되어 있는가?에 대한 점이다. Microsoft사를 예로 들어보자. Microsoft사는 Word, PowerPoint 등 많은 프로그램을 보유하고 있다. Office관련 프로그램을 통틀어 우리는 Microsoft Office라고 부르기도 하는데, 왜 Microsoft사에서는 하나의 Office 프로그램이 아니라 여러 프로그램\(Word, Powerpoint\)으로 분할해놨을까?

사업적인 목적도 있을 수 있겠으나 본질적으로는 하나의 커다란 프로그램으로 운영할 경우 발생하는 비효율성 때문이다. 거대한 프로그램은 실행할 때 부팅 시간도 오래 걸리고 메모리 사용에 있어서도 심각한 비효율성을 초래한다. 이런 여러가지 불편한 점이 있기에 여러가지 프로그램으로 분할해 놓은 것이다.

위와 같은 이유로 리눅스 운영체제 또한 Kernel, Shell, Utility 등 여러가지 프로그램으로 나뉘어져 있다.

Note: \*는 임의의 문자를 뜻한다. 즉, 여기서 \*.c라 함은 helloWolrd.c, goodByeWorld.c와 같이 나타낼 수도 있다. 또한 .out의 확장자의 경우 리눅스 운영체제에서 사용되는 실행파일 확장자고 .exe의 경우 윈도우 운영체제에서 사용되는 실행파일 확장자다.



#### 커널\(Kernel\)이란?

**Kernel**은 본질적으로 프로그램이다. 우리가 흔히 아는 main\( \)으로 시작하는 프로그램 말이다.

하지만 다른 모든 프로그램과는 다르게 커널만이 가지고 있는 특별한 점이 있다. 그것은 바로 **'Memory Resident' **라는 점이다. **메모리에 항상 상주해 있는 것**이 바로 커널이다.

![](/assets/1.PNG)

커널이 아닌 다른 프로그램들은 메모리에 있어도 되고 없어도 된다.** 'Disk Resident' **라고 표현한다. // 필요할 때마다 그 때 그 때 메모리에 로딩해서 사용하면 된다는 의미다.

커널은 **'Memory Resident'** 특징을 제외하곤 아주 평범한 C program이다. 커널을 제외한 다른 프로그램들을 우리는 **Uitility**라고 하는데 위에서 언급했듯 **disk resident**하다. 항상 현 주소가 **disk**라는 의미다. 유저가 필요할 때 요청을 하면 그 때 메모리에 올라오는\(로딩되는\) 것이다. 그런 의미에서 **Utility**를 우리는 **Command**라고도 칭한다. Utility와 Command를 동의어로 생각하고 공부해보자.



#### 쉘\(Shell\)이란?

우리 디스크에는 수십 수백개의 프로그램들이 존재한다. 이 프로그램들이 언제 메모리에 로딩되고 언제 메모리에서 해제되는지 누가 관리해줄까? 관리해주는 프로그램이 꼭 필요하지 않을까?

위와 같은 필요에 의해 탄생한 것이 쉘이다. 많은 프로그램들의 메모리 교통 정리를 해주는 역할을 한다. 유틸리티 중 하나로 쉘의 1차적인 임무는 **'Job control'**이다. Utility, Command, Job을 동의어로 생각하고 공부해보자.



#### 파일\(file\)이란? \(유닉스에 한정함\)

유닉스\(Unix\)에서 파일은 **sequence of bytes**를 의미한다. 말 그대로 바이트들의 배열이란 뜻이다. // 모든 함수, 명령어들은 결국 기계어로 해석하면 0과 1의 나열에 불과하다.

특히 유닉스, 리눅스에서는 **I/O device**도 file로 취급한다. 당장 이해가 안되겠지만, 입출력 기계들\(하드 디스크, USB, 키보드 등\)을 파일로 취급한다고 알고 있으면 된다.

Note: 유닉스, 리눅스에서 입출력 기계들은 **/dev/hd0, /dev/hd1, /dev/tty2**등 파일로서 다뤄지고 입출력 기계와 1:1로 대응된다.



#### 커널과 쉘, 그리고 유틸리티의 관계

아래의 이미지를 살펴보면, 좌측에 메모리 그리고 우측에 디스크가 있다. 커널과 쉘, 그리고 유틸리티들이 디스크와 메모리에서 어떻게 동작하는지 살펴보자.

![](/assets/2.PNG)

맨 처음 시스템을 부팅하면 제일 먼저 메인 메모리에 Kernel\(a.out\)이 올라온다. Kernel\(a.out\)이라는 건 커널 실행파일이 메모리에 올라옴을 의미한다. 리눅스는 멀티 유저 시스템으로 하나의 시스템에 다양한 유저가 들어온다는 사실을 상기하고 아래의 그림을 살펴보자.

![](/assets/3.PNG)

그 다음에 유저가 터미널에 전원을 키면 그 터미널 위에서 쉘 이란 프로그램이 메인 메모리에 올라온다. 그 다음 쉘은 유저가 키보드로 커맨드를 입력하기를 기다린다. 유저가 커맨드를 입력하면, 쉘은 커맨드에 대응하는 유틸리티를 디스크로부터 가져와서 실행시킨다. 각 유저로부터 전원이 들어올 때마다 이 3개의 프로그램\(커널, 쉘, 유틸리티\)의 관계가 형성됨을 알 수 있다.

당장 이해가 어려울 수 있다. 키보드로 커맨드를 입력하길 기다리고 그에 대응하는 유틸리티를 디스크로부터 가져와 실행시킨다는 것이 무슨 말일까? 이 키워드를 이해하기 위해서는 리눅스가 멀티유저 시스템이라는 점과 CLI\(Command Line Interface\)라는 점을 상기해야 한다. 더 자세한 설명은 계속해서 나오니 따라가보자.

위 내용들을 다시 한 번 정리하자면 이렇다. 커널은 운영체제이며 항상 메모리에 상주해 있다. 나머지 프로그램들은 전부 유틸리티이며 디스크에 상주한다.

유틸리티는 항상 디스크에 있다가 필요할 때마다 메모리에 올라오고 사용하지 않을 때는 다시 내려간다. 유틸리티를 우리는 커맨드라고도 칭하며 커맨드들의 교통정리를 하는 것이 쉘의 역할이다.

쉘한테 우리가 ppt라고 커맨드를 입력하면 쉘은 child process로 ppt를 생성한다. child process도 추후에 나오는 개념이니 그렇다고 일단 넘어가보자.



#### 터미널은 뭐고 콘솔은 뭘까?

이 파트는 [KLDP의 게시물](https://kldp.org/node/21751)을 참조하여 작성했습니다.

콘솔은 전통적으로 보면 계기판과 입력장치의 모음과 비슷한 것들의 집합으로 컴퓨터를 조작하기 위한 조작부라고 생각하면 된다.

옛날 대형컴퓨터는 serial\(rs232, 422, 485\)를 이용하여 터미널이라는 장치와 연결하여 조작하였고, 아직도 몇몇 은행에서는 이러한 장비들을 볼 수 있다. 터미널이라는 장비는 CRT와 키보드로 구성되어 있으며 Teraterm, 넷텀, 하이퍼터미널과 같은 프로그램들은 모두 터미널 에뮬레이터라고 불렸다. 이들은 일반 PC를 터미널 대용으로 사용할 수 있도록 해주는 역할을 한다. '터미널'을 통해 '콘솔'과 통신한다 라고 생각해보자.

이해를 쉽게하기 위해 터미널은 콘솔의 부분집합이라고 생각하는 것도 좋겠다. 아래 커널 컴파일의 도움말에 기술된 내용을 보면, 리눅스에서 콘솔과 터미널은 거의 동일한 의미로 사용되고 있다고 볼 수 있기 때문이다.

> If you say Y here, you will get support for terminal devices with display and keyboard devices. These are called "virtual" because you can run several virtual terminals \(also called virtual consoles\) on one physical terminal.

### 

### 운영체제 비교, 리눅스 vs 윈도우

#### 자원의 소모에 대하여

운영체제에는 종류가 굉장히 많지만 가장 대표적이라고 일컬어지는 리눅스와 윈도우를 한 번 비교해보려 한다. 윈도우는 Personal Computer에 사용되는 운영체제다. 개인 컴퓨터에 쓰인다는 것은 나홀로 사용자라는 것, 즉 싱글유저 시스템이라는 의미다. 리눅스가 멀티유저 시스템으로 만들어진 것과는 상반된다.

싱글유저 시스템일 때는 보안문제에 대해서 신경을 별로 안 써도 되지만, 멀티유저 시스템일 때는 보안에 특히 신경을 써야한다. 이유는 간단하다. 멀티유저 시스템은 그 안에 내 파일 뿐만 아니라 다른 사람의 파일 또한 존재하기 때문이다. 내가 다른 사람의 파일을 멋대로 읽고 쓸 수 있다면? 즉 삭제하고 변경할 수 있다면? 이라는 물음을 던지면 쉽게 이해가 갈 것이다.

또 하나의 이슈는 메모리 관리다. 멀티유저 시스템에서는 한정된 자원을 모두가 효율적으로 이용해야 하기 때문에 메모리 관리가 상당히 중요하다. 반면 윈도우와 같은 싱글유저 시스템에서는 멀티유저 시스템만큼 메모리 관리에 신경을 덜 써도 된다.

> 내 돈 내고 구입한 컴퓨터\(장비\)인데, 내가 아니면 누가 써? 나만 쓸거야!

위의 한 문장이 싱글유저 시스템의 기본 철학이다. 그래서 PC는 일찌감치 윈도우 운영체제와 함께 결합된다. 윈도우는 GUI\(Graphic User Interface\)를 채택하고 있기 때문이다. 일반 사용자 입장에서 화면에 일일이 키보드로 명령어를 입력하는 것보다 마우스 몇 번 클릭해서 프로그램을 실행하고 관리하는 것이 훨씬 편하기 때문이다.

반면 리눅스, 유닉스 등의 멀티유저 시스템은 CLI\(Command Line Interface\)를 채택한다. 윈도우에서는 내가 사용할 수 있는 유틸리티\(프로그램, 커맨드와 동의어\)가 아이콘으로 보기 좋게 화면에 표시되는데, 리눅스는 man이라는 명령어로 내가 사용할 수 있는 커맨드가 무엇인지 알아내거나 사전에 알고 있어야 원활한 사용이 가능하다.

![](/assets/4.PNG)

윈도우는 사용자에게 편리한 인터페이스를 제공하는 대신, 동일 작업 대비 훨씬 많은 자원을 요구한다. 리눅스는 사용자에게 다소 불리한 인터페이스를 제공하는 대신, 딱 Char만큼의 자원을 쓰는 등 효율적인 자원 사용을 가능케한다.

#### 보안 이슈에 대하여

윈도우와는 다르게 리눅스에서는 보안이 매우 중요하다. 위에서 언급한 상황을 다시 생각해보자. 만일 한 프로세스가 다른 프로세스의 정보를 함부로 I/O 하려고 하면 어떨까? 즉, 다른 프로세스의 파일을 삭제하거나 내용을 바꿀 수 있다면? 그것만큼 끔찍한 일도 없을 것이다. 어제 힘들게 작성한 보고서를 자신의 가장 친한 친구가 실수로 삭제했다고만 생각해도 화가 치미는데, 모르는 사람이 그런다면... 상상하기도 싫다.

이러한 보안문제를 해결하기 위해 리눅스에서는 사전방지\(Prevent\)하기 위해 많은 노력을 하게된다. 사후처리가 아닌 사전방지\(Prevent\)하는 이유 또한 간단하다. 내 파일이 삭제된 이후에 복구하는 뻘짓보다는 사전에 그런 행위를 못하게 막는 것이 훨씬 효율적이고 철학적으로도 옳다.







