# 1강

#### 커널을 공부하는 마음가짐

**리눅스 커널\(Linux Kernel\)**을 한 사람이 전부 아는 것은 불가능하다. 커널 관련 두터운 원서를 75 ~ 80권 정도는 읽어야 "아, 한 번씩은 훑어봤다"라고 말할 수 있을 정도다. IBM과 같은 대형회사에서도 리눅스를 다루는 사람만 250명 정도가 있다고 한다. 250명의 사람이 방대한 커널에서 각자 분야를 맡아서 일을 처리한다.

따라서 **"모든 걸 다 알아야지!" **라는 마음가짐 보다는** "커널과 운영체제가 어떤 식으로 동작하는지 개략적으로 이해해보자"**라는 수준의 마음가짐을 가지는 것이 좋겠다.

#### 운영체제란?

**운영체제\(Operating System\)**란 하드웨어 자원들\(cpu, memory, disk, tty\)을 **관리하고** 프로그램들을 **지원\(support\) 해주는 것**이다. \(우측에 있는 그림을 살펴보면, Operating System의 아래에 하드웨어들이 있고 그 위로는 프로그램들이 있다.\)

![](/assets/0.PNG)

다르게 표현해본다면, **하드웨어를 감추고 겉으로 다른 프로그램들을 지원해준다**고 생각할 수 있다. 하드웨어를 감춘다는 건, 프로그램을 사용하는 사람이 편하게 쓸 수 있게 각종 기반 작업을 지원한다는 것으로 이해할 수 있다.

Note: 일반적으로 우리는 파워포인트나 워드를 쓸 때 프로그램이 cpu와 memory와 어떻게 소통하는지 등에 대해서 따로 신경쓰지 않는다. 이는 다 운영체제 덕분이다.

#### 프로그램이란?

코딩을 해봤다면 main\( \)함수의 존재에 대해서 알 것이다. 프로그램이란 main\( \)함수를 포함하여 다른 다양한 기능들을 하는 함수들이 모인 존재라고 생각할 수 있다. 함수들이 적혀 있는 소스코드 파일을 컴파일 하면 프로그램이 된다는 것을 우리는 알고 있다.

\*.c 파일을 컴파일해서 a.out 혹은 \*.exe 등이 생성되고 우리는 이걸 프로그램이라 부른다.

여기서 한 가지 생각해볼 점이 있다. 왜 대부분의 프로그램은 분리되어 있는가?에 대한 점이다. Microsoft사를 예로 들어보자. Microsoft사는 Word, PowerPoint 등 많은 프로그램을 보유하고 있다. Office관련 프로그램을 통틀어 우리는 Microsoft Office라고 부르기도 하는데, 왜 Microsoft사에서는 하나의 Office 프로그램이 아니라 여러 프로그램\(Word, Powerpoint\)으로 분할해놨을까?

사업적인 목적도 있을 수 있겠으나 본질적으로는 하나의 커다란 프로그램으로 운영할 경우 발생하는 비효율성 때문이다. 거대한 프로그램은 실행할 때 부팅 시간도 오래 걸리고 메모리 사용에 있어서도 심각한 비효율성을 초래한다. 이런 여러가지 불편한 점이 있기에 여러가지 프로그램으로 분할해 놓은 것이다.

위와 같은 이유로 리눅스 운영체제 또한 Kernel, Shell, Utility 등 여러가지 프로그램으로 나뉘어져 있다.

Note: \*는 임의의 문자를 뜻한다. 즉, 여기서 \*.c라 함은 helloWolrd.c, goodByeWorld.c와 같이 나타낼 수도 있다. 또한 .out의 확장자의 경우 리눅스 운영체제에서 사용되는 실행파일 확장자고 .exe의 경우 윈도우 운영체제에서 사용되는 실행파일 확장자다.

#### 커널\(Kernel\)이란?

**Kernel**은 본질적으로 프로그램이다. 우리가 흔히 아는 main\( \)으로 시작하는 프로그램 말이다.

하지만 다른 모든 프로그램과는 다르게 커널만이 가지고 있는 특별한 점이 있다. 그것은 바로 **'Memory Resident' **라는 점이다. **메모리에 항상 상주해 있는 것**이 바로 커널이다.

![](/assets/1.PNG)

커널이 아닌 다른 프로그램들은 메모리에 있어도 되고 없어도 된다.** 'Disk Resident' **라고 표현한다. // 필요할 때마다 그 때 그 때 메모리에 로딩해서 사용하면 된다는 의미다.

커널은 **'Memory Resident'** 특징을 제외하곤 아주 평범한 C program이다. 커널을 제외한 다른 프로그램들을 우리는 **Uitility**라고 하는데 위에서 언급했듯 **disk resident**하다. 항상 현 주소가 **disk**라는 의미다. 유저가 필요할 때 요청을 하면 그 때 메모리에 올라오는\(로딩되는\) 것이다. 그런 의미에서 **Utility**를 우리는 **Command**라고도 칭한다. Utility와 Command를 동의어로 생각하고 공부해보자.

#### 쉘\(Shell\)이란?

우리 디스크에는 수십 수백개의 프로그램들이 존재한다. 이 프로그램들이 언제 메모리에 로딩되고 언제 메모리에서 해제되는지 누가 관리해줄까? 관리해주는 프로그램이 꼭 필요하지 않을까?

위와 같은 필요에 의해 탄생한 것이 쉘이다. 많은 프로그램들의 메모리 교통 정리를 해주는 역할을 한다. 유틸리티 중 하나로 쉘의 1차적인 임무는 **'Job control'**이다. Utility, Command, Job을 동의어로 생각하고 공부해보자.

#### 파일\(file\)이란? \(유닉스에 한정함\)

유닉스\(Unix\)에서 파일은 **sequence of bytes**를 의미한다. 말 그대로 바이트들의 배열이란 뜻이다. // 모든 함수, 명령어들은 결국 기계어로 해석하면 0과 1의 나열에 불과하다.

특히 유닉스, 리눅스에서는 **I/O device**도 file로 취급한다. 당장 이해가 안되겠지만, 입출력 기계들\(하드 디스크, USB, 키보드 등\)을 파일로 취급한다고 알고 있으면 된다.

Note: 유닉스, 리눅스에서 입출력 기계들은 **/dev/hd0, /dev/hd1, /dev/tty2**등 파일로서 다뤄지고 입출력 기계와 1:1로 대응된다.

#### 커널과 쉘, 그리고 유틸리티의 관계

아래의 이미지를 살펴보면, 좌측에 메모리 그리고 우측에 디스크가 있다. 커널과 쉘, 그리고 유틸리티들이 디스크와 메모리에서 어떻게 동작하는지 살펴보자.

![](/assets/2.PNG)

맨 처음 시스템을 부팅하면 제일 먼저 메인 메모리에 Kernel\(a.out\)이 올라온다. Kernel\(a.out\)이라는 건 커널 실행파일이 메모리에 올라옴을 의미한다. 리눅스는 멀티 유저 시스템으로 하나의 시스템에 다양한 유저가 들어온다는 사실을 상기하고 아래의 그림을 살펴보자.

![](/assets/3.PNG)

그 다음에 유저가 터미널에 전원을 키면 그 터미널 위에서 쉘 이란 프로그램이 메인 메모리에 올라온다. 그 다음 쉘은 유저가 키보드로 커맨드를 입력하기를 기다린다. 유저가 커맨드를 입력하면, 쉘은 커맨드에 대응하는 유틸리티를 디스크로부터 가져와서 실행시킨다. 각 유저로부터 전원이 들어올 때마다 이 3개의 프로그램\(커널, 쉘, 유틸리티\)의 관계가 형성됨을 알 수 있다.

당장 이해가 어려울 수 있다. 키보드로 커맨드를 입력하길 기다리고 그에 대응하는 유틸리티를 디스크로부터 가져와 실행시킨다는 것이 무슨 말일까? 이 키워드를 이해하기 위해서는 리눅스가 멀티유저 시스템이라는 점과 CLI\(Command Line Interface\)라는 점을 상기해야 한다. 더 자세한 설명은 계속해서 나오니 따라가보자.

위 내용들을 다시 한 번 정리하자면 이렇다. 커널은 운영체제이며 항상 메모리에 상주해 있다. 나머지 프로그램들은 전부 유틸리티이며 디스크에 상주한다.

유틸리티는 항상 디스크에 있다가 필요할 때마다 메모리에 올라오고 사용하지 않을 때는 다시 내려간다. 유틸리티를 우리는 커맨드라고도 칭하며 커맨드들의 교통정리를 하는 것이 쉘의 역할이다.

쉘한테 우리가 ppt라고 커맨드를 입력하면 쉘은 child process로 ppt를 생성한다. child process도 추후에 나오는 개념이니 그렇다고 일단 넘어가보자.

#### 터미널은 뭐고 콘솔은 뭘까?

콘솔은 전통적으로 보면 계기판과 입력장치의 모음과 비슷한 것들의 집합으로 컴퓨터를 조작하기 위한 조작부라고 생각하면 된다.

옛날 대형컴퓨터는 serial\(rs232, 422, 485\)를 이용하여 터미널이라는 장치와 연결하여 조작하였고, 아직도 몇몇 은행에서는 이러한 장비들을 볼 수 있다. 터미널이라는 장비는 CRT와 키보드로 구성되어 있으며 Teraterm, 넷텀, 하이퍼터미널과 같은 프로그램들은 모두 터미널 에뮬레이터라고 불렸다. 이들은 일반 PC를 터미널 대용으로 사용할 수 있도록 해주는 역할을 한다. '터미널'을 통해 '콘솔'과 통신한다 라고 생각해보자.

이해를 쉽게하기 위해 터미널은 콘솔의 부분집합이라고 생각하는 것도 좋겠다. 아래 커널 컴파일의 도움말에 기술된 내용을 보면, 리눅스에서 콘솔과 터미널은 거의 동일한 의미로 사용되고 있다고 볼 수 있기 때문이다. 

> If you say Y here, you will get support for terminal devices with display and keyboard devices. These are called "virtual" because you can run several virtual terminals \(also called virtual consoles\) on one physical terminal.

#### 운영체제 비교, 리눅스 vs 윈도우

운영체제에는 종류가 굉장히 많지만 가장 대표적이라고 일컬어지는 리눅스와 윈도우를 한 번 비교해보려 한다. 윈도우는 Personal Computer에 사용되는 운영체제다. 개인 컴퓨터에 쓰인다는 것은 나홀로 사용자라는 것, 즉 싱글유저 시스템이라는 의미다. 리눅스가 멀티유저 시스템으로 만들어진 것과는 상반된다.



