# 1강

#### 커널을 공부하는 마음가짐

**리눅스 커널\(Linux Kernel\)**을 한 사람이 전부 아는 것은 불가능하다. 커널 관련 두터운 원서를 75 ~ 80권 정도는 읽어야 "아, 한 번씩은 훑어봤다"라고 말할 수 있을 정도다. IBM과 같은 대형회사에서도 리눅스를 다루는 사람만 250명 정도가 있다고 한다. 250명의 사람이 방대한 커널에서 각자 분야를 맡아서 일을 처리한다.

따라서 **"모든 걸 다 알아야지!" **라는 마음가짐 보다는** "커널과 운영체제가 어떤 식으로 동작하는지 개략적으로 이해해보자"**라는 수준의 마음가짐을 가지는 것이 좋겠다.

#### 운영체제란?

**운영체제\(Operating System\)**란 하드웨어 자원들\(cpu, memory, disk, tty\)을 **관리하고** 프로그램들을 **지원\(support\) 해주는 것**이다. \(우측에 있는 그림을 살펴보면, Operating System의 아래에 하드웨어들이 있고 그 위로는 프로그램들이 있다.\)

![](/assets/0.PNG)

다르게 표현해본다면, **하드웨어를 감추고 겉으로 다른 프로그램들을 지원해준다**고 생각할 수 있다. 하드웨어를 감춘다는 건, 프로그램을 사용하는 사람이 편하게 쓸 수 있게 각종 기반 작업을 지원한다는 것으로 이해할 수 있다.

Note: 일반적으로 우리는 파워포인트나 워드를 쓸 때 프로그램이 cpu와 memory와 어떻게 소통하는지 등에 대해서 따로 신경쓰지 않는다. 이는 다 운영체제 덕분이다.

#### 프로그램이란?

코딩을 해봤다면 main\( \)함수의 존재에 대해서 알 것이다. 프로그램이란 main\( \)함수를 포함하여 다른 다양한 기능들을 하는 함수들이 모인 존재라고 생각할 수 있다. 함수들이 적혀 있는 소스코드 파일을 컴파일 하면 프로그램이 된다는 것을 우리는 알고 있다.

\*.c 파일을 컴파일해서 a.out 혹은 \*.exe 등이 생성되고 우리는 이걸 프로그램이라 부른다. 

여기서 한 가지 생각해볼 점이 있다. 왜 대부분의 프로그램은 분리되어 있는가?에 대한 점이다. Microsoft사를 예로 들어보자. Microsoft사는 Word, PowerPoint 등 많은 프로그램을 보유하고 있다. Office관련 프로그램을 통틀어 우리는 Microsoft Office라고 부르기도 하는데, 왜 Microsoft사에서는 하나의 Office 프로그램이 아니라 여러 프로그램\(Word, Powerpoint\)으로 분할해놨을까?

사업적인 목적도 있을 수 있겠으나 본질적으로는 하나의 커다란 프로그램으로 운영할 경우 발생하는 비효율성 때문이다. 거대한 프로그램은 실행할 때 부팅 시간도 오래 걸리고 메모리 사용에 있어서도 심각한 비효율성을 초래한다. 이런 여러가지 불편한 점이 있기에 여러가지 프로그램으로 분할해 놓은 것이다.

위와 같은 이유로 리눅스 운영체제 또한 Kernel, Shell, Utility 등 여러가지 프로그램으로 나뉘어져 있다.

Note: \*는 임의의 문자를 뜻한다. 즉, 여기서 \*.c라 함은 helloWolrd.c, goodByeWorld.c와 같이 나타낼 수도 있다. 또한 .out의 확장자의 경우 리눅스 운영체제에서 사용되는 실행파일 확장자고 .exe의 경우 윈도우 운영체제에서 사용되는 실행파일 확장자다.

#### 커널\(Kernel\)이란?

**Kernel**은 본질적으로 프로그램이다. 우리가 흔히 아는 main\( \)으로 시작하는 프로그램 말이다.

하지만 다른 모든 프로그램과는 다르게 커널만이 가지고 있는 특별한 점이 있다. 그것은 바로 **'Memory Resident' **라는 점이다. **메모리에 항상 상주해 있는 것**이 바로 커널이다.

![](/assets/1.PNG)

커널이 아닌 다른 프로그램들은 메모리에 있어도 되고 없어도 된다.** 'Disk Resident' **라고 표현한다. // 필요할 때마다 그 때 그 때 메모리에 로딩해서 사용하면 된다는 의미다.

커널은 **'Memory Resident'** 특징을 제외하곤 아주 평범한 C program이다. 커널을 제외한 다른 프로그램들을 우리는 **Uitility**라고 하는데 위에서 언급했듯 **disk resident**하다. 항상 현 주소가 **disk**라는 의미다. 유저가 필요할 때 요청을 하면 그 때 메모리에 올라오는\(로딩되는\) 것이다. 그런 의미에서 **Utility**를 우리는 **Command**라고도 칭한다. // Utility와 Command를 동의어로 생각하고 공부해보자.

#### 쉘\(Shell\)이란?

우리 디스크에는 수십 수백개의 프로그램들이 존재한다. 이 프로그램들이 언제 메모리에 로딩되고 언제 메모리에서 해제되는지 누가 관리해줄까? 관리해주는 프로그램이 꼭 필요하지 않을까?

위와 같은 필요에 의해 탄생한 것이 쉘이다. 많은 프로그램들의 메모리 교통 정리를 해주는 역할을 한다. 유틸리티 중 하나로 쉘의 1차적인 임무는 **'Job control'**이다. // Utility, Command, Job을 동의어로 생각하고 공부해보자.

#### 파일\(file\)이란? \(유닉스에 한정함\)

유닉스\(Unix\)에서 파일은 **sequence of bytes**를 의미한다. 말 그대로 바이트들의 배열이란 뜻이다. // 모든 함수, 명령어들은 결국 기계어로 해석하면 0과 1의 나열에 불과하다.

특히 유닉스, 리눅스에서는 **I/O device**도 file로 취급한다. 당장 이해가 안되겠지만, 입출력 기계들\(하드 디스크, USB, 키보드 등\)을 파일로 취급한다고 알고 있으면 된다.

