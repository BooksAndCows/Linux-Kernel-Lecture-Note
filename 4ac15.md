# 4강\(by Bookstore3\)

---

이번 4강에서는 지금까지 배운 시스템 콜인 fork\(\)을 통해 프로세스를 생성해 내는 과정에 대해 더 자세히 알아보는 시간을 갖는다.  또 PCB 내용을 분류해 볼 것이며 fork\(\)와는 조금 다른 clone\(\)에 대해서도 다룰 예정이다. 이번 강의는 부모 프로세스가 어떻게 자식 프로세스를 어떤 과정을 통해서 만들어 내는지를 확실히 알아야 이해할 수 있기에 먼저 지금까지 배운 내용 중 일부분을 복습을 하고 4강을 진행 할 것이다.

## 복습

---

지금까지 한 내용들은 아래 두개의 그림에 전부 다 담아져 있다. 이 그림들에 나와있는 순서들을 머리속에 담아만 둘 수 있다면 앞으로 좀 더 심화적인 내용을 배울때 더욱 수월 할 것이다.

![](/assets/Chapter 4_1.PNG)

가운데에 커널이 있다. 그리고 좌측에 우리의 프로그램인 쉘이 있다고 하자. 또 여기서 프로세스는 Parent와 Child 두개만 있다고 가정하자. 원래라면 더 많은 프로세스들이 있기 때문에 CPU를 넘겨줄 때 바로바로 넘겨 받지는 못한다는 점 알아두자.

1. 먼저 우리 프로그램에다 ls 명령어를 쳤다고 가정하자. 그러면 프로그램은 ls라는 자식을 만들려고 할 것이다.
2. 그럼 자식을 만들기 위해 먼저 **fork\(\)**를 한다. 이때 이 fork\(\)는 쉘에 있는게 아니라 커널안에 있는 것이다. 그럼 fork\(\)가  우리 프로그램과 똑같은 데이터를 복사해 만들어 줄 것이다.\(이때 점선은 실제 컨트롤 한다는 뜻이 아니라 데이터가 복사 된다는 뜻이다.\)
3. 그렇게 fork\(\)를 하고나서 다시 돌아와서 **PID 값**을 비교해 보니 Parent 값이니 else로 간다.
4. 이렇게 else로 들어온 Parent는 **wait\(\)**을 시스템 콜 한다. 이때 wait\(\)를 한 이유는 Parent가 **CPU**를 포기해 Child에게 넘겨주기 위한 것이다.
5. 그러면 wait\(\)에서 CPU를 전환 시켜주기 위해 context\_switch\(\)를 하면서 지금까지 했던 Parent의 state vector들을 Parent의 PCB에다가 저장을 시킨다. 그 후 CPU를 기다리고 있는 ready queue에 가서 우선순위가 제일 높은 프로세스의 PCB를 CPU에 연결 시켜 준다. 이때 잠시 알아 둘 것이 커널은 유저마다 **커널 스텍**을 하나씩 가지고 있다는 것을 앞에서 배웠다. 지금 여기까지 상태에서 커널 스텍에는 wait\(\)와 관련된 지역 변수들이 먼저 들어가 있다. 그리고 그 위에 context\_switch\(\)에 관련된 지역 변수들이 저장되어 있다.  Parent의 PCB에는 이러한 정보들이 저장 되는 것이다.
6. 이렇게 CPU를 처음 받게 된 Child는 return부터 해야하는 상황에 처해있다. 이런 상황은 Child가 만들어 질때 부모를 똑같이 복사해 만들어지기 때문에 fork\(\)를 마무리 하고 있던 상황 또한 같이 복사 되어 오기 때문에 일어나는 것이다. 그렇기에 Child는 fork\(\)로 return을 하게 된다. 이러한 상황 때문에 fork\(\)는 한번 가서 두번 돌아온다는 말이 있는 것이다. 단지 이번에는 Child 쪽으로 돌아와 부모 때와 마찬가지로 PID를 가지고 if와 else로 갈지를 결정하게 된다.
7. 이렇게 돌아와서 PID를 보니 Child임으로 if문 안으로 들어가게 된다. 거기서 exec\(\)을 하게 된다.
8. 그럼 디스크에 가서 ls를 찾는다.
9. 그러고 이제 Child 쪽에 디스크에서 찾은 내용을 덮어씌운다. 이렇게 Child는 더 이상 부모의 복제품만이 아닌 자신만의 역할을 하는 프로세스로 성향을 갖게 된다.![](/assets/Chapter 4_2.PNG)
10. 이렇게 exec을 통해 디스크에서 ls를 가져와 덮어씌우고
11. 그러고 Child가 할 일을 알아서 쭉 한다.
12. 일을 다 하고나면 이제 CPU가 필요 없으니 프로세스를 종료하기 위해 exit\(\)을 시스템 콜 한다.
13. 그럼 이제 또 CPU를 다른 프로세스를 주기 위해 context\_switch\(\)를 하게 되고 이때 Parent의 PCB를 불러온다. 그럼 이때 커널의 스텍에는 context\_switch\(\)와 wait\(\)이 들어가 있다.
14. 이럼 이걸 따라서 context\_switch\(\)에서 wait\(\)으로, 그리고 wait\(\)에서 다시 부모쪽에서 wait\(\) 시스템 콜 한 곳으로 돌아가게 된다.

이렇게 해서 fork\(\)의 과정이 끝났다. 이번 복습을 통해 부모의 프로세스가 어떻게 자식 프로세스를 생성하고 자식 프로세스는 어떻게 끝이 나는지에 대해 알아보았다. 그렇다면 이제 본격적으로 fork\(\)를 통해 프로세스를 생성하는 과정을 자세히 알아보자.

## Process Create

---

Parent가 Child를 만들어 내는 프로세스를 할 때 두번의 오버헤드가 발생한다. 이 오버헤드들은 fork\(\)를 하는 도중 발생하며 첫번째 오버헤드는 부모의 image를 자식에게 복사 하며 생기고 두번째는 PCB를 복사하며 생긴다.

이런 프로세스 과정을 더 자세히 알아보기 전에 먼저 PCB의 구성에 대해 알아보자.

> 오버헤드: 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등을 말한다.
>
> A라는 처리를 10초만에 했지만 안전성 고려 때문에 처리가 15초가 걸리는 B의 방식은 오버헤드가 5초가 발생한 것이다. 또한 이러한 B의 방식을 개선해 12초가 걸리면 오버헤드가 3초 단축되었다고 말한다.

### 리눅스 PCB의 구성

![](/assets/Chapter 4_3.PNG)

PCB에는 다양한 정보들이 수 킬로바이트라는 꽤 큰 용량으로 구성되어 있다. 이러한 PCB의 내용을 분류를 하자면 **task basic info**와 프로세스가 오픈한 파일들에 대한 정보가 들어있는** file,** 프로세스가 접근 중인 file system에 대한 정보인** fs**가 있으며 프로세스가 사용 중인 터미널 정보 **tty, **사용 중인 메인 메모리에 대한 정보 **mm**와 여러 신호 정보인 **signals**들로 나눌 수 있다.

리눅스는 이렇게 분류된 요소들을 하나의 구조\(Struct\)로 묶지 않고 그림 오른쪽에 나와 있는 것 처럼 **6개의 구조**로 나눠 관리한다. 그렇다면 이런 구조들은 어떻게 생겼을까.

![](/assets/Chapter 4_4.PNG)

먼저 그림의 왼쪽 상자에 나와있는 것처럼 크게 task\_struct가 있다. 이건 리눅스가 가지고 있는 PCB인데 그 안에는 여러개의 struct들에 대한 내용이 있고 그 옆에 보라색으로 \*mm, \*tty등이 있는 것을 알 수 있다. 이런 **포인터\(\*\)**를 따라가면 각각이 가르키는 파일, 메모리 등에 따라 갈 수 있겠다는 것을 짐작 할 수 있다. 이는 오른쪽 그림에도 나와있는데, 그림을 보면 왼쪽 노란 상자에 task basic info가 있고 그곳에서 화살표로 가르키는 곳을 따라가면 각각의 구조\(struct\)들이 나온다. 이처럼 리눅스의 PCB는 **1개의 구조가 아닌 6개**의 구조로 나눠져 있다.

그렇다면 리눅스는 어째서 1개가 아닌 6개로 나눠서 관리하는 것일까. 이에 대한 답은 다음 그림을 보며 설명하겠다.

![](/assets/Chapter 4_5.PNG)

왼쪽에 있는 노란 상자들을 보자. 저 6개의 상자들이 있어야 하나의 PCB임으로 Child를 만들때 6개 전부를 다 복사해서 줘도 된다. 그러나 그렇게 되면 files, fs, tty, mm, signals 등을 읽어와서 써주고 읽어와서 써주고 하는 많은 작업들이 필요로 해진다. 이처럼 **모든 걸 복사**해서 Child를 만드는데 read\(\) 해주는 byte, write\(\) 해주는 byte가 많이 필요로 하는 제작 과정을 **heavy-weight creation**이라고 한다.

그러나 부모가 가지고 있는 tty나 fs는 자식이 가지고 있는 것과 동일한 경우가 많다. 그렇다면 복사를 하지 않고 자식에게는 부모가 가지고 있는 tty나 fs등의 주소만 알려줘서 같은 걸 사용하게 만들면 되지 않을까라는 생각으로 나온것이 **light-weight creation **방식이다. 자식이 자식만의 방식대로 사용 할 것들만 **선택적으로 복사**하자 라는 방식으로 당연히 복사를 안하면 안할 수록 제일 오버 헤드가 적은 방법이 된다.

자 그럼 이제 게임을 만든다는 상황을 가지고 방금 배운 내용을 적용해보자.

![](/assets/Chapter 4_6.PNG)

먼저 그림을 보면 정 가운데에 검은 네모 상자인 메인 메모리가 있다. 그리고 여러개의 CPU가 있고 CPU마다 프로그램 카운터가 있다. 이런 상황에서 Game XYZ가 돌아가고 있다고 가정하자. 이 게임은 지금 CPU \#0이 돌리고 있고 이런 프로세스를 프로그램 카운터가 가르키고 있다. 그리고 이 CPU를 위해서 PCB가 좌측에 노란 상자로 6개가 있는 상황이다.

이런 상황에서 Child 프로세스를 전통적인 방법으로 만들었다고 생각해 보자. 그럼 a.out도 복사하고 PCB도 똑같이 복사해서 Child를 만들 것이다. 이렇게 되면 위에서 말했던 것 처럼 오버 헤드가 많이 발생하게 된다. 그렇다면 이러한 점은 어떻게 해결을 해야 할까.

> **프로그램 카운터**\(Program counter, **PC**\): 마이크로프로세\(중앙 처리 장\) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 때문에 **명령어 포인터 **라고도 한다.
>
> **프로세서 레지스터**\(Processor Register\): 컴퓨터의 프로세서 안에서 자료를 보관하는 아주 빠른 기억 장소이다. 일반적으로 현재 계산을 수행중인 값을 저장하는 데 사용된다.
>
> **a.out**: 과거 유닉스 계통 운영 체제에서 사용하던 **실행 파일**과 **목적 파일** 형식

![](/assets/Chapter 4_7.PNG)

해결방법은 바로, Child를 프로세스로 만들지 않고 **Thread**로 만드는 방법이다. Thread는 모든 구조를 복사해 오는게 아니라 CPU관련 정보들을 가지고 있는 Task basic info만 복사해 오는것을 칭한다. 그림에서도 보다싶이 자식들은 부모의 구조들을 전부 복사해오지 않고 Task basic info만 복사해 와서 나머지는 부모와 공유해 사용한다. 이러한 방식을 light-weight creation이라고 한다.

> **프로세스와 스레드의 차이**: 프로세스는 운영 체제로부터 **자원을 할당**받는 작업의 단위이 스레드는 프로세스가 할당받은 **자원을 이용**하는 실행의 단위이다.

![](/assets/Chapter 4_8.PNG)

마지막으로 정리를 하자면 리눅스에서 **Thread**는 PCB에서 **Task basic info만 복사**해오고 다른 PCB 데이터는 **공유**를 한다. 이러한 방식으로 데이터의 복사는 줄어 자식 프로세스를 만들때의 오버 헤드가 최소화 된다. 그래서 리눅스에서의 Thread라는 것은 프로세스를 만들때 **light-weight 방식**으로 만드는 것을 칭한다. 그리고 이런 방식은 단순히 복사를 하는 fork\(\)가 아닌 **clone\(\)**이라는 시스템 콜을 사용한다.

![](/assets/Chapter 4_9.PNG)



