# 4강\(by Bookstore3\)

---

이번 4강에서는 지금까지 배운 시스템 콜인 fork\(\)의 과정에 대해 더 자세히 알아보는 시간을 갖는다.  또 PCB 내용을 분류해 볼 것이며 fork\(\)와는 조금 다른 clone\(\)에 대해서도 다룰 예정이다. 이번 강의는 부모 프로세스가 어떻게 자식 프로세스를 어떤 과정을 통해서 만들어 내는지를 확실히 알아야 이해할 수 있기에 먼저 지금까지 배운 내용 중 일부분을 복습을 하고 4강을 진행 할 것이다.

## 복습

---

지금까지 한 내용들은 아래 두개의 그림에 전부 다 담아져 있다. 이 그림들에 나와있는 순서들을 머리속에 담아만 둘 수 있다면 앞으로 좀 더 심화적인 내용을 배울때 더욱 수월 할 것이다.

![](/assets/Chapter 4_1.PNG)

가운데에 커널이 있다. 그리고 좌측에 우리의 프로그램인 쉘이 있다고 하자. 

1. 먼저 우리 프로그램에다 ls 명령어를 쳤다고 가정하자. 그러면 프로그램은 ls라는 자식을 만들려고 할 것이다.
2. 그럼 자식을 만들기 위해 먼저 **fork\(\)**를 한다. 이때 이 fork\(\)는 쉘에 있는게 아니라 커널안에 있는 것이다. 그럼 fork\(\)가  우리 프로그램과 똑같은 데이터를 복사해 만들어 줄 것이다.\(이때 점선은 실제 컨트롤 한다는 뜻이 아니라 데이터가 복사 된다는 뜻이다.\)
3. 그렇게 fork\(\)를 하고나서 다시 돌아와서 **PID 값**을 비교해 보니 Parent 값이니 else로 간다.
4. 이렇게 else로 들어온 Parent는 **wait\(\)**을 시스템 콜 한다. 이때 wait\(\)를 한 이유는 Parent가 **CPU**를 포기해 Child에게 넘겨주기 위한 것이다.
5. 그러면 wait\(\)에서 CPU를 전환 시켜주기 위해 context\_switch\(\)를 하면서 지금까지 했던 Parent의 state vector들을 Parent의 PCB에다가 저장을 시킨다. 그 후 CPU를 기다리고 있는 ready queue에 가서 우선순위가 제일 높은 프로세스의 PCB를 CPU에 연결 시켜 준다. 이때 잠시 알아 둘 것이 커널은 유저마다 **커널 스텍**을 하나씩 가지고 있다는 것을 앞에서 배웠다. 지금 여기까지 상태에서 커널 스텍에는 wait\(\)와 관련된 지역 변수들이 먼저 들어가 있다. 그리고 그 위에 context\_switch\(\)에 관련된 지역 변수들이 저장되어 있다.  Parent의 PCB에는 이러한 정보들이 저장 되는 것이다.
6. 
그리고 우리 프로그램에다 ls라고 명령어를 쳤다 가정하자. 그럼 쉘이 ls를 자식으로 만들어 줄 것이다.



