# 4강\(by Bookstore3\)

---

이번 4강에서는 지금까지 배운 시스템 콜인 fork\(\)을 통해 프로세스를 생성해 내는 과정에 대해 더 자세히 알아보는 시간을 갖는다.  또 PCB 내용을 분류해 볼 것이며 fork\(\)와는 조금 다른 clone\(\)에 대해서도 다룰 예정이다. 이번 강의는 부모 프로세스가 어떻게 자식 프로세스를 어떤 과정을 통해서 만들어 내는지를 확실히 알아야 이해할 수 있기에 먼저 지금까지 배운 내용 중 일부분을 복습을 하고 4강을 진행 할 것이다.

## 복습

---

지금까지 한 내용들은 아래 두개의 그림에 전부 다 담아져 있다. 이 그림들에 나와있는 순서들을 머리속에 담아만 둘 수 있다면 앞으로 좀 더 심화적인 내용을 배울때 더욱 수월 할 것이다.

![](/assets/Chapter 4_1.PNG)

가운데에 커널이 있다. 그리고 좌측에 우리의 프로그램인 쉘이 있다고 하자. 또 여기서 프로세스는 Parent와 Child 두개만 있다고 가정하자. 원래라면 더 많은 프로세스들이 있기 때문에 CPU를 넘겨줄 때 바로바로 넘겨 받지는 못한다는 점 알아두자.

1. 먼저 우리 프로그램에다 ls 명령어를 쳤다고 가정하자. 그러면 프로그램은 ls라는 자식을 만들려고 할 것이다.
2. 그럼 자식을 만들기 위해 먼저 **fork\(\)**를 한다. 이때 이 fork\(\)는 쉘에 있는게 아니라 커널안에 있는 것이다. 그럼 fork\(\)가  우리 프로그램과 똑같은 데이터를 복사해 만들어 줄 것이다.\(이때 점선은 실제 컨트롤 한다는 뜻이 아니라 데이터가 복사 된다는 뜻이다.\)
3. 그렇게 fork\(\)를 하고나서 다시 돌아와서 **PID 값**을 비교해 보니 Parent 값이니 else로 간다.
4. 이렇게 else로 들어온 Parent는 **wait\(\)**을 시스템 콜 한다. 이때 wait\(\)를 한 이유는 Parent가 **CPU**를 포기해 Child에게 넘겨주기 위한 것이다.
5. 그러면 wait\(\)에서 CPU를 전환 시켜주기 위해 context\_switch\(\)를 하면서 지금까지 했던 Parent의 state vector들을 Parent의 PCB에다가 저장을 시킨다. 그 후 CPU를 기다리고 있는 ready queue에 가서 우선순위가 제일 높은 프로세스의 PCB를 CPU에 연결 시켜 준다. 이때 잠시 알아 둘 것이 커널은 유저마다 **커널 스텍**을 하나씩 가지고 있다는 것을 앞에서 배웠다. 지금 여기까지 상태에서 커널 스텍에는 wait\(\)와 관련된 지역 변수들이 먼저 들어가 있다. 그리고 그 위에 context\_switch\(\)에 관련된 지역 변수들이 저장되어 있다.  Parent의 PCB에는 이러한 정보들이 저장 되는 것이다.
6. 이렇게 CPU를 처음 받게 된 Child는 return부터 해야하는 상황에 처해있다. 이런 상황은 Child가 만들어 질때 부모를 똑같이 복사해 만들어지기 때문에 fork\(\)를 마무리 하고 있던 상황 또한 같이 복사 되어 오기 때문에 일어나는 것이다. 그렇기에 Child는 fork\(\)로 return을 하게 된다. 이러한 상황 때문에 fork\(\)는 한번 가서 두번 돌아온다는 말이 있는 것이다. 단지 이번에는 Child 쪽으로 돌아와 부모 때와 마찬가지로 PID를 가지고 if와 else로 갈지를 결정하게 된다.
7. 이렇게 돌아와서 PID를 보니 Child임으로 if문 안으로 들어가게 된다. 거기서 exec\(\)을 하게 된다.
8. 그럼 디스크에 가서 ls를 찾는다.
9. 그러고 이제 Child 쪽에 디스크에서 찾은 내용을 덮어씌운다. 이렇게 Child는 더 이상 부모의 복제품만이 아닌 자신만의 역할을 하는 프로세스로 성향을 갖게 된다.![](/assets/Chapter 4_2.PNG)
10. 이렇게 exec을 통해 디스크에서 ls를 가져와 덮어씌우고
11. 그러고 Child가 할 일을 알아서 쭉 한다.
12. 일을 다 하고나면 이제 CPU가 필요 없으니 프로세스를 종료하기 위해 exit\(\)을 시스템 콜 한다.
13. 그럼 이제 또 CPU를 다른 프로세스를 주기 위해 context\_switch\(\)를 하게 되고 이때 Parent의 PCB를 불러온다. 그럼 이때 커널의 스텍에는 context\_switch\(\)와 wait\(\)이 들어가 있다.
14. 이럼 이걸 따라서 context\_switch\(\)에서 wait\(\)으로, 그리고 wait\(\)에서 다시 부모쪽에서 wait\(\) 시스템 콜 한 곳으로 돌아가게 된다.

이렇게 해서 fork\(\)의 과정이 끝났다. 이번 복습을 통해 부모의 프로세스가 어떻게 자식 프로세스를 생성하고 자식 프로세스는 어떻게 끝이 나는지에 대해 알아보았다. 그렇다면 이제 본격적으로 fork\(\)를 통해 프로세스를 생성하는 과정을 자세히 알아보자.

## Process Create

---

Parent가 Child를 만들어 내는 프로세스를 할 때 두번의 오버헤드가 발생한다. 이 오버헤드들은 fork\(\)를 하는 도중 발생하며 첫번째 오버헤드는 부모의 image를 자식에게 복사 하며 생기고 두번째는 PCB를 복사하며 생긴다.

이런 프로세스 과정을 더 자세히 알아보기 전에 먼저 PCB의 구성에 대해 알아보자.

> 오버헤드: 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등을 말한다.
>
> A라는 처리를 10초만에 했지만 안전성 고려 때문에 처리가 15초가 걸리는 B의 방식은 오버헤드가 5초가 발생한 것이다. 또한 이러한 B의 방식을 개선해 12초가 걸리면 오버헤드가 3초 단축되었다고 말한다.

### 리눅스의 PCB와 Thread

![](/assets/Chapter 4_3.PNG)

PCB에는 다양한 정보들이 수 킬로바이트라는 꽤 큰 용량으로 구성되어 있다. 이러한 PCB의 내용을 분류를 하자면 **task basic info**와 프로세스가 오픈한 파일들에 대한 정보가 들어있는** file,** 프로세스가 접근 중인 file system에 대한 정보인** fs**가 있으며 프로세스가 사용 중인 터미널 정보 **tty, **사용 중인 메인 메모리에 대한 정보 **mm**와 여러 신호 정보인 **signals**들로 나눌 수 있다.

리눅스는 이렇게 분류된 요소들을 하나의 구조\(Struct\)로 묶지 않고 그림 오른쪽에 나와 있는 것 처럼 **6개의 구조**로 나눠 관리한다. 그렇다면 이런 구조들은 어떻게 생겼을까.

![](/assets/Chapter 4_4.PNG)

먼저 그림의 왼쪽 상자에 나와있는 것처럼 크게 task\_struct가 있다. 이건 리눅스가 가지고 있는 PCB인데 그 안에는 여러개의 struct들에 대한 내용이 있고 그 옆에 보라색으로 \*mm, \*tty등이 있는 것을 알 수 있다. 이런 **포인터\(\*\)**를 따라가면 각각이 가르키는 파일, 메모리 등에 따라 갈 수 있겠다는 것을 짐작 할 수 있다. 이는 오른쪽 그림에도 나와있는데, 그림을 보면 왼쪽 노란 상자에 task basic info가 있고 그곳에서 화살표로 가르키는 곳을 따라가면 각각의 구조\(struct\)들이 나온다. 이처럼 리눅스의 PCB는 **1개의 구조가 아닌 6개**의 구조로 나눠져 있다.

그렇다면 리눅스는 어째서 1개가 아닌 6개로 나눠서 관리하는 것일까. 이에 대한 답은 다음 그림을 보며 설명하겠다.

![](/assets/Chapter 4_5.PNG)

왼쪽에 있는 노란 상자들을 보자. 저 6개의 상자들이 있어야 하나의 PCB임으로 Child를 만들때 6개 전부를 다 복사해서 줘도 된다. 그러나 그렇게 되면 files, fs, tty, mm, signals 등을 읽어와서 써주고 읽어와서 써주고 하는 많은 작업들이 필요로 해진다. 이처럼 **모든 걸 복사**해서 Child를 만드는데 read\(\) 해주는 byte, write\(\) 해주는 byte가 많이 필요로 하는 제작 과정을 **heavy-weight creation**이라고 한다.

그러나 부모가 가지고 있는 tty나 fs는 자식이 가지고 있는 것과 동일한 경우가 많다. 그렇다면 복사를 하지 않고 자식에게는 부모가 가지고 있는 tty나 fs등의 주소만 알려줘서 같은 걸 사용하게 만들면 되지 않을까라는 생각으로 나온것이 **light-weight creation **방식이다. 자식이 자식만의 방식대로 사용 할 것들만 **선택적으로 복사**하자 라는 방식으로 당연히 복사를 안하면 안할 수록 제일 오버 헤드가 적은 방법이 된다.

자 그럼 이제 게임을 만든다는 상황을 가지고 방금 배운 내용을 적용해보자.

![](/assets/Chapter 4_6.PNG)

먼저 그림을 보면 정 가운데에 검은 네모 상자인 메인 메모리가 있다. 그리고 여러개의 CPU가 있고 CPU마다 프로그램 카운터가 있다. 이런 상황에서 Game XYZ가 돌아가고 있다고 가정하자. 이 게임은 지금 CPU \#0이 돌리고 있고 이런 프로세스를 프로그램 카운터가 가르키고 있다. 그리고 이 CPU를 위해서 PCB가 좌측에 노란 상자로 6개가 있는 상황이다.

이런 상황에서 Child 프로세스를 전통적인 방법으로 만들었다고 생각해 보자. 그럼 a.out도 복사하고 PCB도 똑같이 복사해서 Child를 만들 것이다. 이렇게 되면 위에서 말했던 것 처럼 오버 헤드가 많이 발생하게 된다. 그렇다면 이러한 점은 어떻게 해결을 해야 할까.

> **프로그램 카운터**\(Program counter, **PC**\): 마이크로프로세\(중앙 처리 장\) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 때문에 **명령어 포인터 **라고도 한다.
>
> **프로세서 레지스터**\(Processor Register\): 컴퓨터의 프로세서 안에서 자료를 보관하는 아주 빠른 기억 장소이다. 일반적으로 현재 계산을 수행중인 값을 저장하는 데 사용된다.
>
> **a.out**: 과거 유닉스 계통 운영 체제에서 사용하던 **실행 파일**과 **목적 파일** 형식

![](/assets/Chapter 4_7.PNG)

해결방법은 바로, Child를 프로세스로 만들지 않고 **Thread**로 만드는 방법이다. Thread는 모든 구조를 복사해 오는게 아니라 CPU관련 정보들을 가지고 있는 Task basic info만 복사해 오는것을 칭한다. 그림에서도 보다싶이 자식들은 부모의 구조들을 전부 복사해오지 않고 Task basic info만 복사해 와서 나머지는 부모와 공유해 사용한다. 이러한 방식을 light-weight creation이라고 한다.

> **프로세스와 스레드의 차이**: 프로세스는 운영 체제로부터 **자원을 할당**받는 작업의 단위이 스레드는 프로세스가 할당받은 **자원을 이용**하는 실행의 단위이다.

![](/assets/Chapter 4_8.PNG)

마지막으로 정리를 하자면 리눅스에서 **Thread**는 PCB에서 **Task basic info만 복사**해오고 다른 PCB 데이터는 **공유**를 한다. 이러한 방식으로 데이터의 복사는 줄어 자식 프로세스를 만들때의 오버 헤드가 최소화 된다. 그래서 리눅스에서의 Thread라는 것은 프로세스를 만들때 **light-weight 방식**으로 만드는 것을 칭한다. 그리고 이런 방식은 단순히 복사를 하는 fork\(\)가 아닌 **clone\(\)**이라는 시스템 콜을 사용한다.

![](/assets/Chapter 4_9.PNG)

clone\(\) 시스템 콜을 살펴보기 위해 위의 그림을 살펴보자. 가운데 clone\(\) 시스템 콜이 있다. clone\(\)을 할 때에는 바이너리 비트 5개를 같이 보낸다. 해서 만약 이 5개의 비트가 전부 11111이면 모든걸 복사하고 00000이면 Task basic info만 복사해오는 제일 light-weight 복사 방식을 하라는 것을 뜻한다.

여기서 만약 clone\(\)의 바이너리 비트 5개가 clone\(11111\)이면 모든 걸 복사하는 전통적인 heavy-weight 방식인 fork\(\)를 해달라는 의미와 같은 뜻이 된다.

> Unlike fork\(2\), these calls allow the child process to share parts of its execution context with the calling process.

## Process Copy

---

이제까지 프로세스가 생성 되는 과정에 대해서 알아보았다. 그리고 우리는 Parent가 Child를 생성 할 때 두가지 오버 헤드가 생긴다는 것을 배웠다. 첫번째는 PCB를 복사할 때 생기고 두번째는 image를 복사 할 때 생긴다. 여기서 약간의 비유를 하자면 PCB는 하얀색 도화지의 속성\(크기, 질감, 모양\)이라면 image는 그 도화지 위에 색칠된 그림이라고 볼 수 있을 것이다. 그렇기에 PCB보다는 image를 복사해 오는 오버 헤드가 더 크게 발생한다.

이렇게 복사가 될 때, 우리는 부모한테 ls를 하면 바로 자식이 자기만의 속성을 갖고 태어나는 것이 아니라 먼저 부모를 복사하고 그 위에 자식이 갖는 속성을 덮어 씌운다는 것을 배웠다. 이는 어찌보면 어리석은 일이라고 생각 할 수도 있다. 어차피 덮어씌울 걸 왜 부모의 image까지 복사하는 과정이 필요한 것일까.

물론 이런 완전한 복사가 항상 비효율적이라는 것은 아니다. 어떤 유저는 부모가 가지고 있던걸 정확히 똑같이 복사 하고 싶어할 수도 있다. 예를 들어 hwp 문서를 키고 또 똑같은 hwp 문서를 새로 키고 싶어하는 경우도 있을 수 있기 때문이다. 그러나 대부분은 이메일을 키고 거기서 이메일을 쓰는 일을 하듯이 부모 프로세스와는 다른 일 처리를 하는 경우가 대부분이다.

그래서 생각해 낸 방식이 모든 코드를 복사해 올 것이 아니라 **페이지 매핑 테이블만 복사**해 오자는 방법이다. 이 방법을 사용하면 Child는 image를 Parent로 부터 가져오는 것이 아니라 Parent의 image를 가르키는 페이지 매핑 테이블만 복사해서 가져오게 된다. Child는 이제 이런 페이지 매핑 테이블을 가지고 execute를 하게 되고 Instruction을 가져오는 동안에는 부모와 **같은 페이지**를 쓸 수 있게 된다.

> **페이지 테이블**: 페이징 기법에 사용되는 자료구조로서, 프로세스의 페이지 정보를 저장하고 있는 테이블이다. 테이블 내용은 해당 페이지에 할당된 물리 메모리의 시작 주소를 담고있다.
>
> **페이징 기법**: 컴퓨터가 메인 메모리에서 사용하기 위해 2차 기억 장로부터 데이터를 저장하고 검색하는 메모리 관리 기법

그런데 이렇게 같은 페이지를 쓰다보면 문제가 생기는 경우가 발생한다. 자식 부모 둘다 페이지에서 read\(\) 해서 읽는건 상관이 없지만 만약 페이지에** write\(\)**를 해서 무언가를 페이지에 쓰게 된다면 어떻게 될까. 이런 경우에는 하는 수 없이 그** 페이지에 대해서만 부모와 자식 하나씩 복사**본을 따로 만들어 주면 된다. 이런 과정을 **Copy on Write\(COW\)**라고 부른다.

![](/assets/Chapter 4_10.PNG)

Copy On Write 방식을 이용하면 처음 시작할 때 자식에게는 페이지 테이블만 있을뿐 독자적인 image라는 것은 없다. 그러나 부모나 자식중 하나라도 페이지에 변화를 주면 그 부분만 복사를 하게 된다. 이런 방식은 image를 약간은 게으르게\(lazy\) 만들어 주는 방식으로 볼 수도 있을 것이다.

자 그럼 다시 그림을 보면서 따라가 보자. 먼저 부모쪽에서 fork\(\)를 하게 된다. 이번 경우에는 옛날 방식처럼 전부다 복사 하는 것이 아니라 COW 방식으로 테이블만 복사해 가져온다. 그리고 나서 fork\(\)를 했던 곳으 돌아온다. 그리고 나서 wait\(\)을 시스템 콜 해서 CPU를 넘겨주려 할 것이다. 그럼 이제 CPU가 자식한테 넘어가서 자식도 fork\(\)로 돌아와서 자식만의 일들을 할 것이다. 이때 자식이 페이지를 읽어 오는건 상관없지만 write\(\)를 하게 되면 그 페이지에 대해서만 복사를 한다고 배웠다.

그런데 다행이라고 봐야하는지 보통 Child는 fork\(\)에서 돌아오면 거의 바로 exec\(\)을 하게 된다. 즉 전에 복사를 했든 안했든 자신만의 코드로 싹 갈아엎는다. 문제는 Parent가 fork\(\)를 하고나서 돌아오고 나서 생긴다. 부모가 fork\(\)에서 돌아와서 **바로 wait\(\)를 안하고 다른 일을 처리**할 경우 3분의 1 정도는 보통 write\(\)의 기능을 한다. 이런 행위는 계속해서 Copy On Write를 하게 될 것이고 이렇게 복사 된 값들은 사실 Child의 exec\(\)을 하게 되면 어차피 덮어 씌워지기 때문에 결국에는 의미없는 복사를 하고 있는게 된다.

