# 4강\(by Bookstore3\)

---

이번 4강에서는 지금까지 배운 시스템 콜인 fork\(\)의 과정에 대해 더 자세히 알아보는 시간을 갖는다.  또 PCB 내용을 분류해 볼 것이며 fork\(\)와는 조금 다른 clone\(\)에 대해서도 다룰 예정이다. 이번 강의는 부모 프로세스가 어떻게 자식 프로세스를 어떤 과정을 통해서 만들어 내는지를 확실히 알아야 이해할 수 있기에 먼저 지금까지 배운 내용 중 일부분을 복습을 하고 4강을 진행 할 것이다.

## 복습

---

지금까지 한 내용들은 아래 두개의 그림에 전부 다 담아져 있다. 이 그림들에 나와있는 순서들을 머리속에 담아만 둘 수 있다면 앞으로 좀 더 심화적인 내용을 배울때 더욱 수월 할 것이다.

![](/assets/Chapter 4_1.PNG)

가운데에 커널이 있다. 그리고 좌측에 우리의 프로그램인 쉘이 있다고 하자. 또 여기서 프로세스는 Parent와 Child 두개만 있다고 가정하자. 원래라면 더 많은 프로세스들이 있기 때문에 CPU를 넘겨줄 때 바로바로 넘겨 받지는 못한다는 점 알아두자.

1. 먼저 우리 프로그램에다 ls 명령어를 쳤다고 가정하자. 그러면 프로그램은 ls라는 자식을 만들려고 할 것이다.
2. 그럼 자식을 만들기 위해 먼저 **fork\(\)**를 한다. 이때 이 fork\(\)는 쉘에 있는게 아니라 커널안에 있는 것이다. 그럼 fork\(\)가  우리 프로그램과 똑같은 데이터를 복사해 만들어 줄 것이다.\(이때 점선은 실제 컨트롤 한다는 뜻이 아니라 데이터가 복사 된다는 뜻이다.\)
3. 그렇게 fork\(\)를 하고나서 다시 돌아와서 **PID 값**을 비교해 보니 Parent 값이니 else로 간다.
4. 이렇게 else로 들어온 Parent는 **wait\(\)**을 시스템 콜 한다. 이때 wait\(\)를 한 이유는 Parent가 **CPU**를 포기해 Child에게 넘겨주기 위한 것이다.
5. 그러면 wait\(\)에서 CPU를 전환 시켜주기 위해 context\_switch\(\)를 하면서 지금까지 했던 Parent의 state vector들을 Parent의 PCB에다가 저장을 시킨다. 그 후 CPU를 기다리고 있는 ready queue에 가서 우선순위가 제일 높은 프로세스의 PCB를 CPU에 연결 시켜 준다. 이때 잠시 알아 둘 것이 커널은 유저마다 **커널 스텍**을 하나씩 가지고 있다는 것을 앞에서 배웠다. 지금 여기까지 상태에서 커널 스텍에는 wait\(\)와 관련된 지역 변수들이 먼저 들어가 있다. 그리고 그 위에 context\_switch\(\)에 관련된 지역 변수들이 저장되어 있다.  Parent의 PCB에는 이러한 정보들이 저장 되는 것이다.
6. 이렇게 CPU를 처음 받게 된 Child는 return부터 해야하는 상황에 처해있다. 이런 상황은 Child가 만들어 질때 부모를 똑같이 복사해 만들어지기 때문에 fork\(\)를 마무리 하고 있던 상황 또한 같이 복사 되어 오기 때문에 일어나는 것이다. 그렇기에 Child는 fork\(\)로 return을 하게 된다. 이러한 상황 때문에 fork\(\)는 한번 가서 두번 돌아온다는 말이 있는 것이다. 단지 이번에는 Child 쪽으로 돌아와 부모 때와 마찬가지로 PID를 가지고 if와 else로 갈지를 결정하게 된다.
7. 이렇게 돌아와서 PID를 보니 Child임으로 if문 안으로 들어가게 된다. 거기서 exec\(\)을 하게 된다.
8. 그럼 디스크에 가서 ls를 찾는다.
9. 그러고 이제 Child 쪽에 디스크에서 찾은 내용을 덮어씌운다. 이렇게 Child는 더 이상 부모의 복제품만이 아닌 자신만의 역할을 하는 프로세스로 성향을 갖게 된다.![](/assets/Chapter 4_2.PNG)
10. 이렇게 exec을 통해 디스크에서 ls를 가져와 덮어씌우고
11. 그러고 Child가 할 일을 알아서 쭉 한다.
12. 일을 다 하고나면 이제 CPU가 필요 없으니 프로세스를 종료하기 위해 exit\(\)을 시스템 콜 한다.
13. 그럼 이제 또 CPU를 다른 프로세스를 주기 위해 context\_switch\(\)를 하게 되고 이때 Parent의 PCB를 불러온다. 그럼 이때 커널의 스텍에는 context\_switch\(\)와 wait\(\)이 들어가 있다.
14. 이럼 이걸 따라서 context\_switch\(\)에서 wait\(\)으로, 그리고 wait\(\)에서 다시 부모쪽에서 wait\(\) 시스템 콜 한 곳으로 돌아가게 된다.



