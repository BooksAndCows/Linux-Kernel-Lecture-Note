# 8강\(by Bookstore3\)

---

이번 8강의 내용은 7강의 마지막 내용의 연장과 IRQ의 처리를 더욱 효율적으로 처리하기 위한 방법으로 나온 Top-Half와 Bottom-Half에 대해서 배우게 될 것이다. 8강을 시작하기 전에 간단하게 복습 또한 할 것이고, 7강을 잘 따라왔다면 크게 어려운 내용은 없을 것 이니 걱정하지 말고 8강을 시작해 보자.

---

## 8.1 복습

![](/images/lk_0801.png)

그럼 이제 잠시 IRQ 인터럽트가 어떻게 일어나며 그 과정이 어떤식으로 일어났는지 잠시 그림과 함께 알아보자.

먼저 APIC에 여러개의 IRQ 라인이 달려있다. 이 라인들에는 여러개의 장치들이\(이 그림에서는 dev \#1, dev \#2\) 붙어있다. 먼저 이 장치들이 인터럽트를 요청을 하면 그 장치가 붙어있던 m번째 IRQ 라인을 통해 인터럽트를 하게 된다. 그럼 이 인터럽트 요청은 여러개의 IRQ 라인들을 관리하는 APIC\(Advanced Programmable Interrupt Controller\)에게 전달이 된다. 이때, 이 IRQ에서는 한 장치의 인터럽트 요구를 수행중인 것이기 때문에 이 IRQ에 붙어있는 다른 장치들의 인터럽트 요청은 잠시 대기 된다.

이런 전달을 요청받은 APIC은 지금 가장 일을 덜 했던 CPU를 찾아 신호를 보내 이 요청에 반응을 해 줄 것을 요구한다. 만약 CPU i가 이 요청을 받게 되면, CPU i는 요청을 받았다는 것을 인지했다고 하며 ACK 신호를 보내준다. 이런 상태를 IRQPENDING이라고 한다. IRQ\_PENDING이란, CPU가 인지를 했고 그에 따른 ACK\(Acknowledge\) 신호를 보냈지만 아직 커널이 이 인터럽트가 요구하는 일들을 해준 상태가 아니라는 뜻이다.

이제 그럼 CPU i는 실제로 요청이 들어온 인터럽트의 해야 할 일, ISR\(Interrupt Service Routine\)을 누가 실제로 처리를 하게 만들지 정한다. 여기서 CPU i에게 APIC이 요청을 했으니 CPU i가 당연히 해야하는거 아니냐고 물어볼 수도 있다. 물론 만약 m번째 IRQ의 인터럽트 요청이 완전 처음이라 다른 CPU가 IRQ 라인에서 일을 하고 있지 않다면 당연히 CPU i가 일을 처리하러 간다. 본인에게 인터럽트가 온 IRQ에게 가서 IRQ\_INPROGRESS, 즉, 지금 일을 하고 있는 중입니다 라는 신호를, 마치 호텔에서 청소할때 문앞에 거는 싸인처럼 ,문앞에 걸어두고 일을 처리할 것이다. 그러나 만약 CPU i가 인터럽트 요청을 받기전에 또 다른 장치로부터 인터럽트 요청이 있었고 그때의 요청은 CPU j가 맡고 있는 경우가 있을 수도 있다. 만약 그렇다면 CPU i가 들어가서 일을 처리하려는 ISR에는 지금 이미 CPU j가 본인이 맡은 일을 처리 중 이라는 말이다.

먼저 CPU j가 이렇게 일을 하고 있다고 이런 상황에서 CPU i

