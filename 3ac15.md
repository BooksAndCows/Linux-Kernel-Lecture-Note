# 3강\(By wisecow\)

---

2강에서 설명을 시작했던 fork\( \)의 작동 원리에 대해서 계속 진행한다. 먼저 앞으로 나올 템플릿들에 오류가 있다는 점을 언급하고 싶다. 오류가 있는 부분은 별도로 빨간색으로 마크해서 원래 있어야할 곳으로 표식을 해놨으니 참고 바란다.

![](/assets/Chapter 3_0.PNG)

그림에서 수정된 사안이 하나 있는데, printf\("I am parent!\n"\) 부분이 else 구문에 속하는 그림이 맞다.

위의 코드를 바탕으로 돌아가고 있는 프로그램이 쉘\(Shell\) 프로그램이라고 가정해보자. 쉘 프로그램으로 인해 명령어를 입력할 수 있는 터미널 혹은 프롬프트 창이 떴고 사용자로부터 명령이 오기만을 기다리고 있다.

우리가 쉘에 한글 프로그램을 실행시키는 명령어 'hwp'라는 명령을 입력했다고 해보자. 그럼 쉘이 가장먼저 하는 작업은 fork\( \)이고, fork\( \)를 하게 되면 자식 프로세스가 생성되면서 위 그림에 있는 코드를 그대로 복사해간다. 코드 뿐만 아니라 부모의 PCB\(Process Control Block\)를 그대로 물려 받는다. \(PCB에 대해서는 2강 강의노트에서 자세히 다뤘으니, 기억이 나지 않는다면 2강 강의노트에서 PCB 키워드로 검색을 해서 확인하길 바란다.\)

아직은 부모 프로세스가 CPU를 점유하고 있기에 fork\( \)로부터 리턴된 pid값을 가지고 프로그램을 마저 진행한다. 생성된 자식 프로세스는 현재 readyList에서 CPU가 자신에게 할당되기를 기다리는 중이다.

앞서 2강에서 fork\( \)는 두 번 리턴된다고 설명한 바 있다. 첫 번째 리턴에서는 부모의 pid\(Process Id\)를 리턴하므로 if 조건문을 건너 띄고 else 구문으로 넘어간다. else구문으로 넘어가면 printf\("I am parent!\n"\); 가 실행되고 모니터 화면에는 I am parent 가 나타나게 될 것이다. 이렇게 부모 프로세스는 종료가 된다. 이후 CPU의 점유권은 자식 프로세스에게 넘어가게 된다. \(readyList에 다른 프로그램들은 없었다고 가정한다면, 부모 프로세스가 끝남과 동시에 자식 프로세스는 CPU를 쥐게 된다.\)

자식 프로세스는 어떻게 동작할까? 위에서 fork\( \)가 일어남과 동시에 부모의 코드 뿐만 아니라 PCB를 통째로 복사해갔기 때문에 다음에 어디서부터 실행해야할 지 알려주는 PC\(Program Counter\)와 SP\(Stack Pointer\) 등 또한 복사되었다. 즉 PCB에 존재하는 State Vector Save Area영역에 있는 PC와 SP 등을 복사했기 때문에 자식 프로세스의 코드가 실행될 때는 맨 처음부터 실행되는 것이 아니라 fork\( \) 중간에서부터 다시 진행하게 되어 있다.

대부분의 프로그램은 초기 실행될 때 main\( \)부터 시작한다. PCB에 그렇게 명시되어 초기화가 되기 때문이다. 하지만 지금 다루고 있는 자식 프로세스의 경우는 PCB에서 가리키고 있는 다음 실행주소가 fork\( \)에 있었기 때문에, 자식프로세스는 fork\( \)부터 진행한다. \(단, 이 때도 이미 부모는 fork\( \)를 한 번 실행했기 때문에 두 번째 실행하는 상황에서부터 시작한다. 바로 이러한 점에서 2번 리턴을 하게끔 되어 있는 것이다.\)

자식 프로세스가 fork\( \)에서 리턴되면, 자식 프로세스 코드 안의 pid 변수는 0의 값을 가지기 때문에 I am Child \n이 화면에 출력되게 된다. 지금까지 다룬 내용을 다시한 번 정리하면서 아래 템플릿을 살펴보자.

![](/assets/Chapter 3_1.PNG)

위에서 수정했던 것과 마찬가지로 일단, printf\("I am Parent\n"\)는 else문에 속해 있어야 하는 것을 염두하고 살펴보면, 첫 번째 출력값인 I am Parent는 일단 부모 프로세스가 시행한 작업이다. 그리고 부모프로세스가 끝나면서 자식 프로세스가 CPU를 점유하게 되면서 if문 조건을 만족하게 되고, printf\("I am Child \n"\)를 실행하게 된다. 따라서 I am Child는 자식 프로세스가 시행한 작업이라고 할 수 있다. 또한 자식 프로세스는 부모 프로세스와 다르게 시간을 출력하는 구문도 포함하고 있기 때문에 마지막에 출력된 시간 또한 자식 프로세스가 진행한 작업이라고 할 수 있다.



