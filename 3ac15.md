# 3강\(By wisecow\)

---

2강에서 설명을 시작했던 fork\( \)의 작동 원리에 대해서 계속 진행한다. 먼저 앞으로 나올 템플릿들에 오류가 있다는 점을 언급하고 싶다. 오류가 있는 부분은 별도로 빨간색으로 마크해서 원래 있어야할 곳으로 표식을 해놨으며 중간 중간 언급을 했으니 부디 헷갈리지 않길 바란다.

## 주요 시스템 콜 동작 원리

### 1. Fork\(2\)의 동작 원리

![](/assets/Chapter 3_0.PNG)

그림에서 수정된 사안이 하나 있는데, printf\("I am parent!\n"\) 부분이 else 구문에 속하는 그림이 맞다.

위의 코드를 바탕으로 돌아가고 있는 프로그램이 쉘\(Shell\) 프로그램이라고 가정해보자. 쉘 프로그램으로 인해 명령어를 입력할 수 있는 터미널 혹은 프롬프트 창이 떴고 사용자로부터 명령이 오기만을 기다리고 있다.

우리가 쉘에 한글 프로그램을 실행시키는 명령어 'hwp'라는 명령을 입력했다고 해보자. 그럼 쉘이 가장먼저 하는 작업은 fork\( \)이고, fork\( \)를 하게 되면 자식 프로세스가 생성되면서 위 그림에 있는 코드를 그대로 복사해간다. 코드 뿐만 아니라 부모의 PCB\(Process Control Block\)를 그대로 물려 받는다. \(PCB에 대해서는 2강 강의노트에서 자세히 다뤘으니, 기억이 나지 않는다면 2강 강의노트에서 PCB 키워드로 검색을 해서 확인하길 바란다.\)

아직은 부모 프로세스가 CPU를 점유하고 있기에 fork\( \)로부터 리턴된 pid값을 가지고 프로그램을 마저 진행한다. 생성된 자식 프로세스는 현재 readyList에서 CPU가 자신에게 할당되기를 기다리는 중이다.

앞서 2강에서 fork\( \)는 두 번 리턴된다고 설명한 바 있다. 첫 번째 리턴에서는 부모의 pid\(Process Id\)를 리턴하므로 if 조건문을 건너 띄고 else 구문으로 넘어간다. else구문으로 넘어가면 printf\("I am parent!\n"\); 가 실행되고 모니터 화면에는 I am parent 가 나타나게 될 것이다. 이렇게 부모 프로세스는 종료가 된다. 이후 CPU의 점유권은 자식 프로세스에게 넘어가게 된다. \(readyList에 다른 프로그램들은 없었다고 가정한다면, 부모 프로세스가 끝남과 동시에 자식 프로세스는 CPU를 쥐게 된다.\)

자식 프로세스는 어떻게 동작할까? 위에서 fork\( \)가 일어남과 동시에 부모의 코드 뿐만 아니라 PCB를 통째로 복사해갔기 때문에 다음에 어디서부터 실행해야할 지 알려주는 PC\(Program Counter\)와 SP\(Stack Pointer\) 등 또한 복사되었다. 즉 PCB에 존재하는 State Vector Save Area영역에 있는 PC와 SP 등을 복사했기 때문에 자식 프로세스의 코드가 실행될 때는 맨 처음부터 실행되는 것이 아니라 fork\( \) 중간에서부터 다시 진행하게 되어 있다.

대부분의 프로그램은 초기 실행될 때 main\( \)부터 시작한다. PCB에 그렇게 명시되어 초기화가 되기 때문이다. 하지만 지금 다루고 있는 자식 프로세스의 경우는 PCB에서 가리키고 있는 다음 실행주소가 fork\( \)에 있었기 때문에, 자식프로세스는 fork\( \)부터 진행한다. \(단, 이 때도 이미 부모는 fork\( \)를 한 번 실행했기 때문에 두 번째 실행하는 상황에서부터 시작한다. 바로 이러한 점에서 2번 리턴을 하게끔 되어 있는 것이다.\)

자식 프로세스가 fork\( \)에서 리턴되면, 자식 프로세스 코드 안의 pid 변수는 0의 값을 가지기 때문에 I am Child \n이 화면에 출력되게 된다. 지금까지 다룬 내용을 다시한 번 정리하면서 아래 템플릿을 살펴보자.

![](/assets/Chapter 3_1.PNG)

위에서 수정했던 것과 마찬가지로 일단, printf\("I am Parent\n"\)는 else문에 속해 있어야 하는 것을 염두하고 살펴보면, 첫 번째 출력값인 I am Parent는 일단 부모 프로세스가 시행한 작업이다. 그리고 부모프로세스가 끝나면서 자식 프로세스가 CPU를 점유하게 되면서 if문 조건을 만족하게 되고, printf\("I am Child \n"\)를 실행하게 된다. 따라서 I am Child는 자식 프로세스가 시행한 작업이라고 할 수 있다. if문 끝단에 있는 execlp 구문 같은 경우는 바로 아래의 단락에서 설명하려 한다.

### 2. Exec\(3\) 동작 원리

![](/assets/Chapter 3_2.PNG)

몇 가지 배경지식에 대해 먼저 짚어보고자 한다. /bin 은 바이너리\(binary\) 파일만 모아둔 폴더\(directory\)를 의미한다. 그 폴더 안에는 바이너리 프로그램들이 수 십개가 존재하고 있는데, 그 바이너리 프로그램 마다 원래는 a.out 의 형식으로 되어 있지만 그 이름을 각자의 프로그램 제작사의 입맛에 맞게끔 설정해 놓았다\(hwp, ppt 등\).  

코드를 살펴 보자면, 자식프로세스 차례가 왔을 때 I am child! 부분의 출력문을 출력하고, execlp\(exec 계열 함수\)를 실행하게 되어 있다. exec 함수 같은 경우, 현재 돌아가고 있는 프로세스 위에 자신의 프로세스를 완전히 덮어씌어\(overlay\) 버린다. 덮어쓴 후 exec 자신의 프로그램의 main\( \)으로 가는 것이 exec의 작동 원리다.

새로운 프로세스가 생기는 것이 아니기 때문에, pid\(Process Id\)는 변하지 않는다. 다만 프로세스를 구성하는 코드\(기계어 코드\)와 데이터, 힙, 그리고 스택 영역의 값들이 exec으로 발생하는 새로운 프로그램의 것으로 바뀌게 된다.

![](/assets/Chapter 3_3.PNG)

설명은 위와 동일하다. exec은 자신의 프로세스를 현재 진행 중인 프로세스 위에 덮어 써버린다. 덮어 씀과 동시에 date의 main\( \)으로 넘어가는 것이고, 그 쪽에서 날짜를 출력해주는 작업을 진행한다. 그래서 유닉스나 리눅스에서는 프로세스의 생성이 fork\( \)하고 exec\( \) 두 스텝이 존재한다.

fork\( \)는 image\(= 소스코드\)와 PCB를 전부 복사하는데, exec\( \)의 경우에는 현재 image에 새로운 실행\(execute\)코드를 디스크로부터 바이너리 파일 형태로 가져온 후에 현재 image에 덮어 씌우기\(overlay\)를 진행하고 자신 프로세스의 main\( \)으로 진행하는 것이다. 한마디로 기존의 작업하던 것을 자신의 프로그램으로 갈아 치우고 자신의 프로그램을 가동시키는 행위라고 할 수 있다.

### 3. Wait\(2\) 동작 원리





