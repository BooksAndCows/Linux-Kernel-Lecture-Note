# 3강\(By wisecow\)

---

2강에서 설명을 시작했던 fork\( \)의 작동 원리에 대해서 계속 진행한다. 먼저 앞으로 나올 템플릿들에 오류가 있다는 점을 언급하고 싶다. 오류가 있는 부분은 별도로 빨간색으로 마크해서 원래 있어야할 곳으로 표식을 해놨으며 중간 중간 언급을 했으니 부디 헷갈리지 않길 바란다.

## 주요 시스템 콜 동작 원리

### 1. Fork\(2\)의 동작 원리

![](/assets/Chapter 3_0.PNG)

그림에서 수정된 사안이 하나 있는데, printf\("I am parent!\n"\) 부분이 else 구문에 속하는 그림이 맞다.

위의 코드를 바탕으로 돌아가고 있는 프로그램이 쉘\(Shell\) 프로그램이라고 가정해보자. 쉘 프로그램으로 인해 명령어를 입력할 수 있는 터미널 혹은 프롬프트 창이 떴고 사용자로부터 명령이 오기만을 기다리고 있다.

우리가 쉘에 한글 프로그램을 실행시키는 명령어 'hwp'라는 명령을 입력했다고 해보자. 그럼 쉘이 가장먼저 하는 작업은 fork\( \)이고, fork\( \)를 하게 되면 자식 프로세스가 생성되면서 위 그림에 있는 코드를 그대로 복사해간다. 코드 뿐만 아니라 부모의 PCB\(Process Control Block\)를 그대로 물려 받는다. \(PCB에 대해서는 2강 강의노트에서 자세히 다뤘으니, 기억이 나지 않는다면 2강 강의노트에서 PCB 키워드로 검색을 해서 확인하길 바란다.\)

아직은 부모 프로세스가 CPU를 점유하고 있기에 fork\( \)로부터 리턴된 pid값을 가지고 프로그램을 마저 진행한다. 생성된 자식 프로세스는 현재 ready queue에서 CPU가 자신에게 할당되기를 기다리는 중이다.

앞서 2강에서 fork\( \)는 두 번 리턴된다고 설명한 바 있다. 첫 번째 리턴에서는 부모의 pid\(Process Id\)를 리턴하므로 if 조건문을 건너 띄고 else 구문으로 넘어간다. else구문으로 넘어가면 printf\("I am parent!\n"\); 가 실행되고 모니터 화면에는 I am parent 가 나타나게 될 것이다. 이렇게 부모 프로세스는 종료가 된다. 이후 CPU의 점유권은 자식 프로세스에게 넘어가게 된다. \(ready queue에 다른 프로그램들은 없었다고 가정한다면, 부모 프로세스가 끝남과 동시에 자식 프로세스는 CPU를 쥐게 된다.\)

자식 프로세스는 어떻게 동작할까? 위에서 fork\( \)가 일어남과 동시에 부모의 코드 뿐만 아니라 PCB를 통째로 복사해갔기 때문에 다음에 어디서부터 실행해야할 지 알려주는 PC\(Program Counter\)와 SP\(Stack Pointer\) 등 또한 복사되었다. 즉 PCB에 존재하는 State Vector Save Area영역에 있는 PC와 SP 등을 복사했기 때문에 자식 프로세스의 코드가 실행될 때는 맨 처음부터 실행되는 것이 아니라 fork\( \) 중간에서부터 다시 진행하게 되어 있다.

대부분의 프로그램은 초기 실행될 때 main\( \)부터 시작한다. PCB에 그렇게 명시되어 초기화가 되기 때문이다. 하지만 지금 다루고 있는 자식 프로세스의 경우는 PCB에서 가리키고 있는 다음 실행주소가 fork\( \)에 있었기 때문에, 자식프로세스는 fork\( \)부터 진행한다. \(단, 이 때도 이미 부모는 fork\( \)를 한 번 실행했기 때문에 두 번째 실행하는 상황에서부터 시작한다. 바로 이러한 점에서 2번 리턴을 하게끔 되어 있는 것이다.\)

자식 프로세스가 fork\( \)에서 리턴되면, 자식 프로세스 코드 안의 pid 변수는 0의 값을 가지기 때문에 I am Child \n이 화면에 출력되게 된다. 지금까지 다룬 내용을 다시한 번 정리하면서 아래 템플릿을 살펴보자.

![](/assets/Chapter 3_1.PNG)

위에서 수정했던 것과 마찬가지로 일단, printf\("I am Parent\n"\)는 else문에 속해 있어야 하는 것을 염두하고 살펴보면, 첫 번째 출력값인 I am Parent는 일단 부모 프로세스가 시행한 작업이다. 그리고 부모프로세스가 끝나면서 자식 프로세스가 CPU를 점유하게 되면서 if문 조건을 만족하게 되고, printf\("I am Child \n"\)를 실행하게 된다. 따라서 I am Child는 자식 프로세스가 시행한 작업이라고 할 수 있다. if문 끝단에 있는 execlp 구문 같은 경우는 바로 아래의 단락에서 설명하려 한다.

### 2. Exec\(2\) 동작 원리

![](/assets/Chapter 3_2.PNG)

몇 가지 배경지식에 대해 먼저 짚어보고자 한다. /bin 은 바이너리\(binary\) 파일만 모아둔 폴더\(directory\)를 의미한다. 그 폴더 안에는 바이너리 프로그램들이 수 십개가 존재하고 있는데, 그 바이너리 프로그램 마다 원래는 a.out 의 형식으로 되어 있지만 그 이름을 각자의 프로그램 제작사의 입맛에 맞게끔 설정해 놓았다\(hwp, ppt 등\).

코드를 살펴 보자면, 자식프로세스 차례가 왔을 때 I am child! 부분의 출력문을 출력하고, execlp\(exec 계열 함수\)를 실행하게 되어 있다. exec 함수 같은 경우, 현재 돌아가고 있는 프로세스 위에 자신의 프로세스를 완전히 덮어씌어\(overlay\) 버린다. 덮어쓴 후 exec 자신의 프로그램의 main\( \)으로 가는 것이 exec의 작동 원리다.

새로운 프로세스가 생기는 것이 아니기 때문에, pid\(Process Id\)는 변하지 않는다. 다만 프로세스를 구성하는 코드\(기계어 코드\)와 데이터, 힙, 그리고 스택 영역의 값들이 exec으로 발생하는 새로운 프로그램의 것으로 바뀌게 된다.

![](/assets/Chapter 3_3.PNG)

설명은 위와 동일하다. exec은 자신의 프로세스를 현재 진행 중인 프로세스 위에 덮어 써버린다. 덮어 씀과 동시에 date의 main\( \)으로 넘어가는 것이고, 그 쪽에서 날짜를 출력해주는 작업을 진행한다. 그래서 유닉스나 리눅스에서는 프로세스의 생성이 fork\( \)하고 exec\( \) 두 스텝이 존재한다.

fork\( \)는 image\(= 소스코드\)와 PCB를 전부 복사하는데, exec\( \)의 경우에는 현재 image에 새로운 실행\(execute\)코드를 디스크로부터 바이너리 파일 형태로 가져온 후에 현재 image에 덮어 씌우기\(overlay\)를 진행하고 자신 프로세스의 main\( \)으로 진행하는 것이다. 한마디로 기존의 작업하던 것을 자신의 프로그램으로 갈아 치우고 자신의 프로그램을 가동시키는 행위라고 할 수 있다.

### 3. Wait\(2\) 동작 원리

![](/assets/Chapter 3_4.PNG)

시스템 콜은 결국 커널모드로 진입하는 것을 뜻하는데, 어떤 프로그램이 wait\( \)를 호출하면 해당 프로그램의 CPU 사용권한을 박탈한다. 위 템플릿의 본문 첫 줄에 등장하는 것처럼 프로세스 P\_A로부터 CPU 사용 권한을 박탈한다\(preempt\).

![](/assets/Chapter 3_5.PNG)

임의의 프로그램 A\(위 템플릿에서 P\_A 라고 표현되어 있음\)가 wait\(2\) 시스템 콜을 호출하면, 커널모드\(K\)의 트랩 핸들러\(Trap Handler\)에 진입하여 wait\( \) 시스템 콜 실행을 하게 되는데 이 때 커널을 부른 프로그램으로부터 CPU를 뺐는다\(preempt\). 풀어쓰자면, 커널은 자신의 작업을 다 하고 나면 해당 프로그램의 유저 모드로 돌아가야 하는데, 유저모드로 돌아가지 않는다.

커널이 아닌 프로그램은 자신의 어드레스에 한정되서 read, jump 등을 수 할 수 있지만 커널은 어디로든 가고 jmp\(점프\)할 수 있기 때문에 ready queue에 가서 준비된 프로세스 중 우선순위가 가장 높은 프로그램의 PCB를 찾아서 PC\(Program Counter\)를 알아낸 후에 PC\(프로그램 카운터\)가 가리키 쪽으로 가는 것\(jmp\)이다. 이 과정이 preempt이다.

![](/assets/Chapter 3_6.PNG)

그 아래의 템플릿을 살펴보자. 이번에는 **부모 프로세스에 초점**을 맞춰서 살펴보자. fork\( \)후에 if문을 통과한 후에 else문에서 부모 프로세스는 자신의 일을 수행한다. 모든 일을 마친 후 소스코드의 마지막으로 가보니 **wait\( \) 시스템 콜을 호출**하고 있다.

![](/assets/Chapter 3_7.PNG)

wait\( \) 시스템 콜을 호출하면, 부모 프로세스는 잠들게 된다. 자식 프로세스가 끝날 때 까지 잠을 잔다. CPU가 이제 내 관할이 아니므로 자식 프로세스에게 넘어가고 자식프로세스는 자신이 할 일을 수행한다. 자식이 하는 일 중에 execlp\("/bin/date"...\)" 라는 명령어가 마지막으로 있으니 해당 명령어를 수행하고 자식 프로세스는 중료한다. 

자식 프로세스가 종료했을 때 CPU는 자식 프로세스로부터 부모 프로세스를 찾는다. 그 후 CPU는 부모 프로세스를 다시 자신의 대기명단\(ready queue\)에 등록시킨다. 이후 부모가 CPU 점유권을 받았을 때! 그 때가 바로 wait\( \) 시스템 콜이 끝나는 지점이다. 부모는 이후 자신의 남은 일이 있었다면 해당 작업을 진행하게 된다.

비유를 들자면, 메일 프로그램을 들 수 있다. 메일 프로그램을 이용하는 목적은 상대에게 메일을 보내는 것이므로 우리는 '메일 쓰기'를 클릭할 것이고, 곧 텍스트를 입력할 수 있는 에디터가 나타난다. 여기서 메일은 부모프로세스고 텍스트 에디터는 자식 프로세스라고 할 수 있는데, 우리가 메일 쓰기를 마치면 자식 프로세스\(텍스트 에디터\)가 종료하면서 부모 프로세스\(메일 프로그램\)가 다시 등장하게 된다.

### Exit\(2\) 동작 원리

메인함수 main\( \)가 끝날 때는 반드시 exit\(2\) 시스템 콜이 존재한다. 설령 우리가 소스 프로그램을 작성할 때, exit\( \)을 직접 기입하지 않았더라도 컴파일러가 알아서 main\( \) { }의 마지막에 exit\(2\) 시스템 콜을 삽입하게 되어 있다. 아래 템플릿을 살펴보자.

![](/assets/Chapter 3_8.PNG)

자식 프로세스\(pid: 0\)의 작업 중 execlp\("/bin/date", ...\)가 있고 위에서 배웠듯이 exec\(2\) 시스템 콜이 실행되면 현재 있는 프로세스 위에 인자로 주어진 프로세스\(date\)를 덮어 씌어버린다. 그리고 곧장 해당 프로세스의 main\( \)을 실행시키게 된다. 원래 저 노란 박스\(main 함수가 들어 있는\)에는 exit\( \)이라는 소스코드가 존재하지 않았다. 하지만 컴파일러가 컴파일을 할 때 삽입을 해줬고, 실제 만들어진 이진파일\(binary file\)을 열어 보면, exit\(2\)에 해당하는 코드가 들어있게 된다.

![](/assets/Chapter 3_9.PNG)

위 템플릿에는 exit\(2\)의 작동 원리가 좀 더 상세하게 적혀 있다. 이후 들어오는 신호들을 전부 무시해버리고, 파일들이 열려 있다면 파일들을 닫는다. 또한 메모리 영역에서 해당 프로세스가 차지하고 있는 부분\(image\)을 해제\(deallocate\) 해버리고, 부모 프로세스에게 통보한다. 그리고 exit\(2\)을 호출한 프로세스의 상태를 좀비\(ZOMBIE\)상태로 설정한다.

커널에서 일어나는 동작으로는 먼저 exit\(2\)을 호출한 프로세스의 CPU를 빼았고, ready queue에 있던 다른 프로세스에게 CPU를 넘겨준다. 이 과정을 스케쥴링\(scheduling\)한다고 표현하는데, 실제로 exit\(2\)을 호출하게 되면 커널 안의 schedule\( \) 함수가 호출된다.

### 시스템 콜 요약 정리 \(Summary\)

### ![](/assets/Chapter 3_10.PNG)

지금까지 우리는 프로세스를 위한 4가지 시스템 콜에 대해 살펴 보았다. fork\( \)는 부모 프로세스와 아주 유사한 자식 프로세스를 만들어 내고, exec\( \)은 진행 중인 프로세스 위에 새로운 프로세스 이미지를 덮어 씌운 후 main\( \) 으로 가게 된다. wait\( \)은 이 시스템 콜을 호출한 프로세스를 잠들게 하는 것이고, exit\( \)은 가지고 있던 모든 자원\(resource\)을 반환하고 부모 프로세스에게 알려주는 역할을 한다.

## Context Switch \(유저 모드와 커널 모드 사이의 전환\)

지금부터 설명하는 내용은, 설명과 함께 템플릿을 봐야 이해가 잘되니 이 점 꼭 유의해서 설명을 차근차근 따라오는 것이 좋겠다.

![](/assets/Chapter 3_11.PNG)

1. 유저가 쉘이 띄어 준 프롬프트에 명령어\("ls"\)를 입력한다. 쉘 입장에서 이 프로세스를 실행시키기 위해서 fork\( \)를 실행한다. 쉘을 바탕으로, 쉘이 부모 프로세스가 되고 새롭게 생기는 프로세스는 자식 프로세스가 된다.
   fork\( \)가 동작하면서 쉘의 PCB와 쉘의 a.out을 그대로 복사한다. 그러나 CPU는 아직 쉘에게 할당 되어 있기 때문에 'ls'가 실행되거나 하진 않는다.

2. 쉘\(Parent\)이 wait\( \)을 콜하게 되고 쉘은 잠들게 된다. 잠들면서 CPU의 대기 리스트\(queue\)에 들어가게 된다. 

3. 자식 프로세스는 부모 프로세스와 똑같은 코드를 가져왔으므로, fork\( \) 중간에서 동작하게 된다. fork\( \)로부터 리턴된 값은 자식 프로세스를 뜻하는 pid인 0값이며 자식프로세스는 execlp\("/bin/ls" ...\)를 실행하게 된다.   

4. 디스크로부터 'ls'를 로드한다. 자식 프로세스가 기존의 부모 프로세스\(쉘\)로부터 그대로 복사해왔던 이미지 위에 그대로 덮어 씌운다\(overwrite\). 덮어 씌운 후 ls의 메인 코드로 가서 코드를 실행한다\(ls가 run한다\).   

5. ls가 끝나면 exit\(2\) 시스템 콜을 하게 되어 있고, exit\(2\)을 부름으로써 다시 커널모드로 들어와서 커널은 CPU를 다른 프로세스에게 할당하게 된다. 이 때 wait\(2\) 시스템 콜이 끝난 것으로 인지를 하게 된다.  

6. \(템플릿에는 7번으로 되어 있음\) 높은 우선순위를 가지고 기다리고 있던 프로세스가 없다면, 기존의 부모 프로세스\(쉘\)는 다시 동작하게 된다.



![](/assets/Chapter 3_12.PNG)

위 템플릿은 쉘의 유저모드와 커널모드를 왔다 갔다 하는 것을 시간 순서로 도식화 해놓은 것이다. 위에 해당하는 부분은 가볍게 훑어보는 것으로 아래의 템플릿으로 넘어가 보자.

![](/assets/Chapter 3_13.PNG)

 Kernel의 경우 하드웨어를 위한 자료구조, 즉 테이블이 하나 존재한다. 그 자료구조를 위 템플릿에서는 struct CPU라고 표현하고 있다. 위 템플릿의 상황을 보자면, 먼저 CPU가 P1을 실행시키고 있다\(파란 글씨로 P1 was running on CPU\). 그리고 P1이 wait\(2\) 시스템 콜을 호출한다. 시스템 콜을 호출함으로써 커널은 CPU state Vector\(PC, SP 등\)를 P1의 PCB에 저장해야 한다.

이렇게 상태 값을 기억하는 이유는 wait\(2\) 시스템 콜이 끝났을 때 다시 정상적으로 작업을 원활하게 진행하기 위해서다. 보다시피 P1과 P2의 PCB는 커널 코드 안에 있다. 커널에는 2종류의 자료구조가 있는데, 하드웨어 자원들 마다\(for each hardware resource\) 존재하고 각 유저 프로세스 마다\(for each user processs\) 존재한다. 

그럼 이제 stateVector에 해당하는 값들을 써주고 \(저장하고\), CPU엔 임자가 이제 없으므로 그 다음 실행해야 할 프로세스를 찾아가야 한다. 그 대기 큐를 따라가면 CPU를 쓰겠다고 줄 슨 프로세스들의 PCB를 살펴보고 우선순위가 제일 높은 놈을 찍는다. 그럼 이제 그 PCB로부터 레지스터 값들을 다 바꿔야 한다. 그럼 이제 PC가 갈아엎어졌고 그럼 이제 그 지점부터 실행되는 것이고 P2가 run을 하게 된다. Context Switching이 일어나게 됐다.

이런 일을 해주는 함수의 이름은 schedule이다. 이것은 internal 함수이고, Kernel a.out에 알려지지 않는 함수다. 커널 밖에서 부를 수 있는 건 시스템 콜이고, 스케쥴은 커널 안에서만 부를 수 있는 함수다.



